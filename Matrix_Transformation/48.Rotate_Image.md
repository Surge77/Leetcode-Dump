# ðŸ”¹ Problem Name: 48. Rotate Image (Array/Matrix, Medium)

**ðŸ”— Link:** [48. Rotate Image](https://leetcode.com/problems/rotate-image/)
**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Layer-by-layer four-way cyclic swap (rotate each ring)
* **Core Concept:** In-place index remapping on an nÃ—nn\\times n matrix
* **When to Use This Pattern?**
  * When asked to **rotate a matrix 90Â° in-place** (memory constraint emphasized).
  * Problems involving **ring-wise transformations** or **cyclic swaps** on matrix borders.
* **Mistakes to Avoid:**
  1. Using `range(r - l + 1)` instead of `range(r - l)` (double-processing the corner).
  2. Mixing up clockwise vs counterclockwise move order.
  3. Forgetting to **update both**`l` and `r` after finishing a layer.
  4. Assuming this works for **non-square** matrices (it doesnâ€™t).
  5. Off-by-one errors in expressions like `bottom - i` and `r - i`.
  6. Overwriting values by not using a temporary slot for the first element.
  7. Trying to handle all four sides with a single loop index but wrong side boundaries.

---

## ðŸ”¹ Optimization Path

* **Brute Force:** Copy into a new matrix using the mapping `new[i][j] = old[n-1-j][i]`.
  * Time: O(n2)O(n^2), Space: O(n2)O(n^2) (not in-place).
* **Optimized Solution (Chosen):** Rotate **each layer** with **four-way swaps** using two pointers `l` and `r`.
  * Time: O(n2)O(n^2), Space: O(1)O(1).
* **Further Improvements Possible?**
  * Alternate in-place method: **Reverse rows â†’ Transpose** (also O(1)O(1) space).
  * Generalize to **k Ã— 90Â°** rotations: repeat operation `(k % 4)` times.
  * Rotate **counterclockwise** by swapping move order or using **Transpose â†’ Reverse rows**.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Treat the matrix as concentric **layers (rings)**. For each layer, perform **4-way cyclic swaps** across the top, right, bottom, and left sides for `i` from `0` to `r - l - 1`.
* **Why This Works?** Each four-way cycle moves an element directly to its final 90Â° clockwise position without extra space. Completing all cycles for a ring rotates the entire ring; then we move inward.
* **Edge Cases Considered:**
  * `n = 1` (no-op)
  * `n = 2` (single swap cycle per side)
  * Odd vs even `n` (center cell in odd `n` remains fixed)
  * Duplicate values (irrelevantâ€”index mapping only)
  * Input must be square

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Two Pointers (boundaries `l/r`), In-place Cyclic Swaps, Layered Matrix Processing.
* **Common Problems Using This:**
  * Rotate Image (this)
  * Transpose Matrix (as a subroutine)
  * Spiral Matrix traversal (layer-wise iteration)
  * Set Matrix Zeroes (in-place state technique)
  * Rotate Array (1D cyclic rotation)

---

## ðŸ”¹ Tricks & Patterns Used

* Two-pointer **layer boundaries**`l` (left/top) and `r` (right/bottom).
* **Four-way cyclic swap** to avoid extra memory.
* Careful **index arithmetic**: `top=l`, `bottom=r`, offsets via `i`.

---

## ðŸ”¹ Alternative Data Structures

* Not needed. A temporary variable per swap cycle suffices.
* For non in-place variants (not allowed here), one could use an auxiliary matrix or Pythonic constructions; they violate space constraints.

---

## ðŸ”¹ Complexity Analysis

* Time Complexity:O(n2)O(n^2) â€” every element is moved exactly once across all layers.
* Space Complexity:O(1)O(1) â€” only a few pointers and a temporary variable.

---

## ðŸ”¹ Code Snippet (Optimized)

```python
from typing import List

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        In-place rotate an n x n matrix by 90Â° clockwise using layer-by-layer
        four-way cyclic swaps.

        Time Complexity:  O(n^2)  â€” each element is touched once
        Space Complexity: O(1)    â€” constant extra memory
        """
        l, r = 0, len(matrix) - 1

        # Process concentric layers
        while l < r:
            # For the current ring, perform n-1 swaps per side
            for i in range(r - l):  # i is the offset along the side
                top, bottom = l, r

                # Save top-left
                top_left = matrix[top][l + i]

                # Perform 4-way rotation (clockwise)
                # bottom-left -> top-left
                matrix[top][l + i] = matrix[bottom - i][l]
                # bottom-right -> bottom-left
                matrix[bottom - i][l] = matrix[bottom][r - i]
                # top-right -> bottom-right
                matrix[bottom][r - i] = matrix[top + i][r]
                # saved top-left -> top-right
                matrix[top + i][r] = top_left

            # Move to inner ring
            l += 1
            r -= 1
```

---

## ðŸ”¹ (Optional) Alternative In-Place Method (for reference)

* **Reverse Rows â†’ Transpose** also rotates 90Â° clockwise:

```python
from typing import List

class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Time:  O(n^2)
        Space: O(1)
        """
        # 1) Reverse the order of rows (vertical flip)
        matrix.reverse()
        n = len(matrix)
        # 2) Transpose across main diagonal
        for i in range(n):
            for j in range(i + 1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```

---

## ðŸ”¹ 80/20 Recall (8ty)

* **Clockwise:** Reverse rows â†’ Transpose **OR** 4-way ring swaps.
* **Counterclockwise:** Transpose â†’ Reverse rows **OR** reversed 4-way order.
* **180Â°:** Reverse rows â†’ Reverse columns (or rotate twice).
