# ðŸ”¹ Problem Name: 21. Merge Two Sorted Lists (Linked List, Easy)

**ðŸ”— Link:** [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)

**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** **Two Pointers (merge variant) + Dummy/Sentinel Head**
* **Core Concept:** Walk both sorted lists, always append the smaller node; use a dummy head to simplify head handling
* **When to Use This Pattern?**

    * Anytime you need to **merge** two sorted linked lists (foundation for merge sort on lists)
* **Mistakes to Avoid:**

    1. Forgetting to advance the pointer (`node = node.next`) after attaching
    2. Not handling empty-input cases (one or both lists `None`)
    3. Over-complicating the first-node logic â€” the **dummy head** removes that

---

## ðŸ”¹ Optimization Path

* **Brute Force (not preferred):** Copy values into an array and sort â†’ breaks O(1) space and loses list structure
* **Optimized Solution (Chosen):** **Iterative merge with dummy**

    * **Time:** O(m + n)
    * **Space:** O(1) extra (reuses nodes)
* **Alternative:** **Recursive merge** (clean but uses call stack)

    * **Time:** O(m + n)
    * **Space:** O(m + n) auxiliary due to recursion depth

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Maintain two cursors `p1` and `p2` over `list1` and `list2`. Keep a `tail` pointer starting at a **dummy node**. Repeatedly attach the smaller of `p1`/`p2` to `tail.next`, advance that listâ€™s pointer and `tail`. Finally, attach the non-empty remainder.
* **Why This Works?** Both lists are already sorted; a single linear pass that always consumes the smaller head preserves sorted order.
* **Edge Cases Considered:** One list empty, both empty, duplicates, negative values.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** **#3 Two Pointers (adjacent)** + **Dummy Head (sentinel)**
* **Common Problems Using This:**

    * Merge k Sorted Lists (pairwise/heap variants)
    * Sort List (merge phase)
    * Merge Two Binary Trees (similar sentinel idea conceptually)

---

## ðŸ”¹ Tricks & Patterns Used

* **Dummy head** to avoid special-casing the first attachment
* **`node.next = list1 or list2`** to append the remainder succinctly
* Reusing nodes (no new allocations besides the dummy)

---

## ðŸ”¹ Alternative Data Structures

* None required beyond the linked list. Recursion uses the call stack implicitly.

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** **O(m + n)** â€” each node visited once
* **Space Complexity:** **O(1)** â€” iterative; reuses existing nodes (ignoring the single dummy)

---

## ðŸ”¹ Code Snippet (Optimized â€” Iterative with Dummy)

```python
# Time: O(m + n) â€” each node visited once
# Space: O(1) â€” constant extra pointers (reuses nodes)
from typing import Optional

# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional['ListNode'], list2: Optional['ListNode']) -> Optional['ListNode']:
        dummy = tail = ListNode()  # sentinel simplifies head handling
        p1, p2 = list1, list2
        
        while p1 and p2:
            if p1.val <= p2.val:
                tail.next = p1
                p1 = p1.next
            else:
                tail.next = p2
                p2 = p2.next
            tail = tail.next
        
        # attach the remaining nodes
        tail.next = p1 or p2
        return dummy.next
```

---

## ðŸ”¹ (Optional) Code Snippet â€” Recursive

```python
# Time: O(m + n)
# Space: O(m + n) â€” recursion stack
from typing import Optional

class Solution:
    def mergeTwoLists(self, list1: Optional['ListNode'], list2: Optional['ListNode']) -> Optional['ListNode']:
        if not list1 or not list2:
            return list1 or list2
        if list1.val <= list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

---

## ðŸ”¹ 80/20 Recall (8ty)

Dummy head â†’ compare heads â†’ attach smaller â†’ advance `tail` and that list â†’ finally attach remainder â†’ **return `dummy.next`**.
