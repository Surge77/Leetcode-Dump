# ğŸ”¹ Problem Name: Subtree of Another Tree (Trees / DFS, Easy)

**ğŸ”— Link:** [LeetCode 572 â€” Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)
**ğŸŸ¢ Status:** âœ… Solved

---

## ğŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Traverse the big tree; at each node, run a full structure-and-value equality check with `subRoot` (top-down recursion). Shortâ€‘circuit on first match.
* **Core Concept:** Tree traversal + structural equality (DFS).
* **When to Use This Pattern?** When you need to verify if a whole subtree appears inside a larger tree with identical structure and node values.
* **Mistakes to Avoid:**

  * Treating partial overlaps as matches (structure must be identical).
  * Mishandling `None` nodes (both must be `None` to match at leaves).
  * Forgetting the base rule: empty `subRoot` is always a subtree.

---

## ğŸ”¹ Optimization Path

* **Brute Force:** Compare `subRoot` against every node via equality check.
  **Time:** Worstâ€‘case O(m * n) where `n` = nodes in `root`, `m` = nodes in `subRoot`.
  **Space:** O(h) recursion stack, `h` = height of `root`.
* **Optimized Solution:** Same recursion + *pruning*: only call deep equality when values match.
  **Time:** Still O(m * n) worstâ€‘case, but prunes heavily in practice.
  **Space:** O(h).
* **Further Improvements Possible?**

  * **Tree serialization + substring search (KMP/Rabinâ€“Karp)** with null markers to avoid structural ambiguity: average O(n + m) string search after O(n + m) serialization.
  * **Merkle hashing / rolling hash on subtrees** to cut repeated equality work; beware collisions (use strong hashing).

---

## ğŸ”¹ Solution Breakdown

* **Optimal Approach:** For each node in `root`, if its value equals `subRoot.val`, run `sameTree` to test exact structural and value equality; otherwise recurse into left and right.
* **Why This Works?** A subtree match must start at some node whose value equals `subRoot.val`, and from there the entire shape and values must align; DFS equality enforces this precisely.
* **Edge Cases Considered:** Empty `subRoot` â†’ `True`; empty `root` with nonâ€‘empty `subRoot` â†’ `False`; repeated values â†’ still correct due to full structure check; skewed trees (heightâ‰ˆn) â†’ stack depthâ‰ˆn.

---

## ğŸ”¹ Pattern Recognition

* **Belongs To:** Tree Traversal (DFS), Structural Equality Check (Topâ€‘Down).
* **Common Problems Using This:**

  * [Same Tree (LeetCode 100)](https://leetcode.com/problems/same-tree/)
  * [Subtree with Maximum Average](https://www.lintcode.com/problem/597/) (conceptual kin)
  * [Serialize and Deserialize Binary Tree (LeetCode 297)](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)
  * [Path Sum variants (LC 112/113)](https://leetcode.com/problems/path-sum/)

---

## ğŸ”¹ Tricks & Patterns Used

* Shortâ€‘circuiting recursion (return on first `True`).
* Clean separation of concerns: global search vs. local equality (`isSubtree` vs. `sameTree`).
* Nullâ€‘aware comparisons to avoid false positives.

---

## ğŸ”¹ Alternative Data Structures

* **Merkle Hashing:** Assign a hash to each subtree `(val, leftHash, rightHash)`; compare hashes instead of full trees for faster rejection.
* **String Serialization:** Preorder with `#` null markers, then KMP/Rabinâ€“Karp to check if `subRoot` string occurs in `root` string.

---

## ğŸ”¹ Complexity Analysis

* **Time Complexity (this recursive solution):** Worstâ€‘case **O(m * n)**.
* **Space Complexity:** **O(h)** for recursion stack, `h` = height of `root`.

---

## ğŸ”¹ Code Snippet (Optimized)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from typing import Optional

class Solution:
    def isSubtree(self, root: Optional['TreeNode'], subRoot: Optional['TreeNode']) -> bool:
        """Return True if subRoot is a subtree of root.
        Time: Worst-case O(m * n)  |  Space: O(h) recursion stack
        n = nodes in root, m = nodes in subRoot, h = height of root.
        """
        if not subRoot:
            return True
        if not root:
            return False
        # Check equality at current node; if not, search children
        if self._sameTree(root, subRoot):
            return True
        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)

    def _sameTree(self, a: Optional['TreeNode'], b: Optional['TreeNode']) -> bool:
        """Exact structural & value equality between two trees."""
        if not a and not b:
            return True
        if not a or not b:
            return False
        if a.val != b.val:
            return False
        return self._sameTree(a.left, b.left) and self._sameTree(a.right, b.right)

"""
ğŸ“Š ANALYSIS
Approach Used: Recursive Traversal with Structural & Value Comparison
The problem is solved using a recursive traversal of the main tree, where at each node, a helper compares the entire subtree (structure and values) with the candidate subtree using a "sameTree" check. If a match isnâ€™t found at the current node, the algorithm recurses left and right.

Complexity:
Time: O(m * n) â€” Best case O(n) if values hardly match; worst case O(m * n) if subRoot matches with many root nodes and must be checked repeatedly.
Space: O(h), with h = height of the input tree, from recursion stack usage.

First Principles:
You must find a node in the main tree where the entire subtree matches subRoot exactly, both in structure and valueâ€”no partial matches allowed.

80/20 Insight:
Mastery Lever: Only do deep subtree checks at nodes where root and subRoot values match. Prune search aggressively.
Pro Edge: Short-circuit on success: bail immediately once a match is found.

Misconceptions:
"Myth: Any overlap counts." â†’ Truth: Only exact structure and value duplication qualifies as a subtree.
"Trap: Null equals Null mishandling." â†’ Reality: Matches only when both nodes are None.
"Edge case confusion: Empty subRoot?" â†’ Clarity: Empty subRoot is universally a subtree, so always return True.

Five Whys â€“ â€œRecursive Mirror Checkâ€:
Why check value first before recursing? â†’ Prevents unnecessary deep matching when roots already differ.
Why use helper (sameTree)? â†’ Cleanly separates global traversal from subtree identity check.
Why descend left/right if not matched? â†’ Subtree can start at any node.
Why short-circuit on True? â†’ Early exit for efficiency.
Why return False only if all paths fail? â†’ Must exhaustively check every possible subtree position.

ğŸš¨ Verdict: Recursive Precision â€” a top-down, node-by-node scan that fuses global search with local identity checks, as precise as it is relentless.
Elegantly combines fast rejection and thorough comparison, making it robust for all binary tree quirks.

ğŸ’¡ â€œCheck-then-Descendâ€ Magic:
Given root = [3,4,5,1,2], subRoot = [4,1,2], checks root/left-child/right-child... SameTree locks on left (4â€¦), walks both trees, confirms match, returns True.

ğŸ”¥ Interview Power Move:
â€œThis solution walks the big tree root-to-leaf; at each node, it runs a total structure-and-value check against the candidate subtree, short-circuiting for max speed. Elegant recursion handles all null edge cases and rejects partial matches perfectly.â€

Evolution Complete:
Naive: Stringify entire tree with markers, search for substring match. O(m+n), fails for structural divergence.
Better: Serialize with null markers for better rigor, but brittle for repeated values.
THIS: One-pass recursive O(m * n) check with pattern-pruning. Structure and valueâ€”no false positives. âœ…

â€œBe the subtree detective: scan, compare, quit on successâ€”never get lost chasing false alarms.â€ ğŸ¯
"""
```

---

## ğŸ”¹ Common Misconceptions (cm)

* Matching only values without structure â†’ false positives.
* Thinking `None` equals anything â†’ both must be `None`.
* Forgetting `subRoot=None` returns `True` by definition.

---

## ğŸ”¹ Extra: Alternative (Serialization + KMP) â€” Outline Only

1. Preorder serialize both trees with `#` for nulls, e.g., `,3,4,1,#,#,2,#,#,5,#,#,`
2. Run KMP to check if `ser(subRoot)` is a substring of `ser(root)`.
   **Pros:** O(n + m) after serialization.
   **Cons:** Careful with separators and null markers to avoid accidental matches; more code.
