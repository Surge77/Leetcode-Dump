# ðŸ”¹ Problem Name: Reorder List (Linked List, Medium)

**ðŸ”— Link:** [143. Reorder List](https://leetcode.com/problems/reorder-list/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Split â†’ Reverse â†’ Merge (alternate weave)
* **Core Concept:** Fast & Slow to find mid, inâ€‘place reversal of second half, twoâ€‘pointer alternating merge.
* **When to Use This Pattern?** Reorder as `L0 â†’ Ln â†’ L1 â†’ Ln-1 â€¦` on a singly linked list with O(1) extra space.
* **Mistakes to Avoid:**

  * Using `fast = head` (can misâ€‘split even lengths).
  * Forgetting `slow.next = None` before merge (cycles/infinite loop).
  * Not storing `next` before rewiring during reversal.
  * Merging past the shorter half (loop should be `while second`).

## ðŸ”¹ Optimization Path

* **Brute Force:** Copy nodes to array/deque, then two-index interleave. **Time:** O(n), **Space:** O(n).
* **Optimized Solution:** Split mid â†’ reverse second half â†’ alternate merge. **Time:** O(n), **Space:** O(1).
* **Further Improvements Possible?** Recursive weave (clean but O(n) stack); deque variant (simpler but O(n) space).

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Find middle with slow/fast, cut; reverse second half; weave nodes from first and reversed second alternately.
* **Why This Works?** Reversing exposes `Ln, Ln-1, â€¦` in forward direction, enabling one linear interleave without extra memory.
* **Edge Cases Considered:** Empty/one/two nodes (noâ€‘op); odd/even lengths; ensure cut before merge.

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Fast & Slow Pointers; Two Pointers (Opposite-End); Inâ€‘Place Linkedâ€‘List Reversal.
* **Common Problems Using This:** 206 Reverse Linked List, 234 Palindrome Linked List, 876 Middle of Linked List, 21 Merge Two Sorted Lists.

## ðŸ”¹ Tricks & Patterns Used

* `prev/curr/nxt` reversal template; save `next` before rewiring.
* Strict cut at mid: `slow.next = None`.
* Alternate merge with `t1, t2` temps.

## ðŸ”¹ Alternative Data Structures

* **Deque/Array** to pop from ends and rebuild list (trades O(1) space for simplicity).

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) (split + reverse + merge).
* **Space Complexity:** O(1) (constant pointers).

## ðŸ”¹ Code Snippet (Optimized)

```python
# Time: O(n) â€” split O(n), reverse O(n), merge O(n)
# Space: O(1) â€” in-place, constant extra pointers
class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        if not head or not head.next:
            return

        # Phase 1: Find middle (slow ends first half)
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # Phase 2: Reverse second half
        second = slow.next
        slow.next = None  # cut
        prev = None
        while second:
            nxt = second.next
            second.next = prev
            prev = second
            second = nxt

        # Phase 3: Merge alternating
        first, second = head, prev
        while second:
            t1, t2 = first.next, second.next
            first.next = second
            second.next = t1
            first, second = t1, t2
```
