# ðŸ”¹ Problem Name: Maximum Depth of Binary Tree (Tree Traversal, Easy)

**ðŸ”— Link:** [LeetCode 104](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Use recursion (DFS) to compute depth as `1 + max(left, right)`
* **Core Concept:** Tree Traversal (DFS recursion / BFS level order)
* **When to Use This Pattern?** Anytime you need height/depth of a tree or longest path from root to leaf
* **Mistakes to Avoid:**

  * Forgetting recursion stack counts toward space complexity
  * Checking for leaf nodes instead of `None`
  * Overcomplicating with visited sets (trees donâ€™t have cycles)

---

## ðŸ”¹ Optimization Path

* **Brute Force:** BFS level-order with queue (O(n) time, O(w) space, where w = max width)
* **Optimized Solution:** Recursive DFS (O(n) time, O(h) space, h = height of tree)
* **Further Improvements Possible?** Iterative DFS with stack (similar complexity, less elegant)

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Recursive DFS
* **Why This Works?** Depth is inherently recursive: each nodeâ€™s depth = 1 + max depth of children
* **Edge Cases Considered:**

  * Empty tree â†’ depth = 0
  * Single node tree â†’ depth = 1
  * Skewed tree â†’ depth = n (worst case)

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Tree Traversal (DFS / BFS)
* **Common Problems Using This:** Minimum Depth of Binary Tree, Balanced Binary Tree, Diameter of Binary Tree

---

## ðŸ”¹ Tricks & Patterns Used

* **Divide and Conquer:** Each node asks its children for their depths
* **Recursion Mirrors Tree Structure:** Perfect alignment of problem and solution

---

## ðŸ”¹ Alternative Data Structures

* **Queue (BFS):** Level-order traversal counting levels
* **Stack (DFS iterative):** Manual recursion replacement

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) â€“ every node visited once
* **Space Complexity:** O(h) â€“ recursion stack depth (O(log n) for balanced, O(n) for skewed)

---

## ðŸ”¹ Code Snippet (Optimized)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))

"""
ðŸ“Š ANALYSIS
â€¢ Time Complexity: O(n) - Each node visited once
â€¢ Space Complexity: O(h) - Recursion stack height (worst O(n), best O(log n))
"""
```
