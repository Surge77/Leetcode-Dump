# 🔹 Problem Name: Missing Number (Bit Manipulation, Easy)

**🔗 Link:** [LeetCode 268 - Missing Number](https://leetcode.com/problems/missing-number/)
**🟢 Status:** ✅ Solved

---

## 🔹 Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Use **XOR cancellation** across indices and array elements.
* **Core Concept:** **Bit Manipulation / XOR properties**
* **When to Use This Pattern?** When elements are guaranteed to be from 0..n with one missing.
* **Mistakes to Avoid:**

  * Forgetting to start XOR with `n` (the upper bound of the range).
  * Misunderstanding XOR → it cancels pairs but keeps the unpaired (missing) number.
  * Confusing this with sum-based methods (overflow risk in other languages).

---

## 🔹 Optimization Path

* **Naive:** Search each number in range, O(n^2).
* **Better:** Use HashSet to track presence, O(n) time & space.
* **Optimized Solution (This):** XOR indices with numbers, O(n) time, O(1) space.
* **Further Improvements Possible?** Sum formula approach: `n*(n+1)//2 - sum(nums)` also O(n), but less elegant.

---

## 🔹 Solution Breakdown

* **Optimal Approach:** XOR all indices and all numbers → pairs cancel, missing number remains.
* **Why This Works?** XOR rules: `a ^ a = 0`, `a ^ 0 = a`. Since each number 0..n should appear once, XORing both sets cancels matches and leaves the missing element.
* **Edge Cases Considered:**

  * Missing `0`.
  * Missing `n`.
  * Array of size 1.

---

## 🔹 Pattern Recognition

* **Belongs To:** Bit Manipulation (XOR Tricks).
* **Common Problems Using This:**

  * [136. Single Number](https://leetcode.com/problems/single-number/)
  * [137. Single Number II](https://leetcode.com/problems/single-number-ii/)
  * [260. Single Number III](https://leetcode.com/problems/single-number-iii/)
  * [389. Find the Difference](https://leetcode.com/problems/find-the-difference/)

---

## 🔹 Tricks & Patterns Used

* **XOR cancellation** to isolate missing number.
* **Start with n** to include the last element in [0, n].
* **Commutative & Associative properties of XOR** guarantee correctness regardless of order.

---

## 🔹 Alternative Data Structures

* **HashSet:** Works but needs O(n) extra space.
* **Sum formula:** Possible but risk of integer overflow in some languages.

---

## 🔹 Complexity Analysis

* **Time Complexity:** O(n).
* **Space Complexity:** O(1).

---

## 🔹 Code Snippet (Optimized)

```python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        xorr = n
        for i in range(n):
            xorr ^= i ^ nums[i]
        return xorr

# ⏱ Time: O(n)
# 💾 Space: O(1)
```

---

✅ **Final Takeaway:** The XOR method is the **cleanest and most space-efficient** way to solve Missing Number. It’s a perfect showcase of **bit manipulation elegance**.
