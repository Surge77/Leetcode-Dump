# ðŸ”¹ Problem Name: Spiral Matrix (Array/Matrix Traversal, Medium)

**ðŸ”— Link:** [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)
**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Boundary shrink (layer-by-layer spiral)
* **Core Concept:** Use four inclusive boundaries to traverse: top row â†’ right col â†’ bottom row â†’ left col, then shrink bounds.
* **When to Use This Pattern?** When you need to read/write matrix elements in spiral/ring/layer order.
* **Mistakes to Avoid:**
  * Forgetting conditional guards before left/up traversals
  * Off-by-one with inclusive ranges
  * Updating boundaries at the wrong time (before finishing a side)

---

## ðŸ”¹ Optimization Path

* **Brute Force:** Use a `visited` set with direction vectors; simulate movement and turn on boundaries â†’ **O(mÂ·n) time, O(mÂ·n) space**.
* **Optimized Solution:** Boundary shrink with four pointers (`row_begin, row_end, col_begin, col_end`) â†’ **O(mÂ·n) time, O(1) extra space**.
* **Further Improvements Possible?** Mostly about code clarity; asymptotics already optimal. You can generalize to counter-clockwise or start from other corners by changing traversal order.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Maintain inclusive bounds: `[row_begin..row_end]` and `[col_begin..col_end]`. Traverse Right, Down, (if valid) Left, (if valid) Up. After each side, shrink the corresponding boundary.
* **Why This Works?** Each spiral layer is a disjoint perimeter. Shrinking boundaries ensures no cell is revisited. Guards handle degenerate cases (single row/column).
* **Edge Cases Considered:**
  * Empty matrix â†’ return []
  * 1Ã—N or NÃ—1 â†’ guards prevent duplicates
  * Single element â†’ works naturally
  * Rectangular (m â‰  n) matrices

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Boundary-Controlled Matrix Traversal (Layered/Perimeter Traversal).
* **Common Problems Using This:**
  * Spiral Matrix II (fill numbers in spiral)
  * Rotate Image (by layers)
  * Set Matrix Zeroes (uses in-place marking pattern #16 conceptually different)
  * Ring Sum / Border Sum

---

## ðŸ”¹ Tricks & Patterns Used

* **Four-Pointer Window on 2D:**`top/bottom/left/right` (here `row_begin/row_end/col_begin/col_end`).
* **Inclusive Bounds Ranges:**`range(col_begin, col_end + 1)` etc.
* **Conditional Guards:** Check `row_begin <= row_end` and `col_begin <= col_end` before left/up traversals.

---

## ðŸ”¹ Alternative Data Structures

* **Visited Grid + Direction Vectors:** Use `dirs = [(0,1),(1,0),(0,-1),(-1,0)]` with a `visited` matrix or set; change direction when hitting boundary/visited. Simpler to reason about but **O(mÂ·n) space**.

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** **O(mÂ·n)** â€” every element visited exactly once.
* **Space Complexity:** **O(1)** auxiliary (output list excluded).

---

## ðŸ”¹ Code Snippet (Optimized)

```python
from typing import List

class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        """
        Returns the elements of the matrix in clockwise spiral order.
        Time: O(m*n) â€” visits each element once
        Space: O(1) auxiliary â€” uses only boundary pointers (excluding output)
        """
        res: List[int] = []
        if not matrix:
            return res

        row_begin, row_end = 0, len(matrix) - 1
        col_begin, col_end = 0, len(matrix[0]) - 1

        while row_begin <= row_end and col_begin <= col_end:
            # Traverse Right
            for j in range(col_begin, col_end + 1):
                res.append(matrix[row_begin][j])
            row_begin += 1

            # Traverse Down
            for i in range(row_begin, row_end + 1):
                res.append(matrix[i][col_end])
            col_end -= 1

            # Traverse Left (if still valid row)
            if row_begin <= row_end:
                for j in range(col_end, col_begin - 1, -1):
                    res.append(matrix[row_end][j])
            row_end -= 1

            # Traverse Up (if still valid col)
            if col_begin <= col_end:
                for i in range(row_end, row_begin - 1, -1):
                    res.append(matrix[i][col_begin])
            col_begin += 1

            # Loop continues while bounds define a non-empty sub-rectangle

        return res
```

---

## ðŸ”¹ Common Misconceptions (cm)

1. **Double-counting middle row/col** â€” forgetting guards before Left/Up in degenerate cases.
2. **Off-by-one errors** â€” mixing inclusive and exclusive ranges; always pair inclusive bounds with `+1` in `range`.
3. **Wrong update order** â€” shrinking boundaries before finishing a side causes skips or repeats.
4. **Assuming square matrix** â€” logic must work for rectangular matrices.

---

## ðŸ”¹ 5 Whys (Root-Cause for Typical Bugs)

1. *Why duplicates?* â†’ Because after Right+Down the sub-rectangle collapsed; missing guard.
2. *Why off-by-one?* â†’ Inclusive bounds but used `range(col_begin, col_end)` instead of `col_end + 1`.
3. *Why skipped cells?* â†’ Boundary decremented before completing traversal.
4. *Why index error?* â†’ Bounds crossed but loop still attempted Left/Up without checks.
5. *Why hard to debug?* â†’ No explicit invariant; add comments stating the four-phase order and when bounds change.

---

## ðŸ”¹ Edge Cases Handled

* `[]`, `[[]]`, `[[x]]`, 1Ã—N, NÃ—1, rectangular mâ‰ n â€” all covered by guards and loop condition.

---

## ðŸ”¹ Real-World Application Scenarios

* Rendering UI grids in spiral reveals, ring-wise image processing, spiral sampling for heatmaps, robotic path planning on discrete cells.
