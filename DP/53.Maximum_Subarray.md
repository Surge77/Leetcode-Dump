# Problem Name: Maximum Subarray (Kadaneâ€™s Algorithm, Easy-Medium)

**ðŸ”— Link:** [LeetCode - Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)

**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Easy to Medium
* **Main Approach:** Kadaneâ€™s Algorithm
* **Core Concept:** Dynamic Programming
* **When to Use This Pattern?**
  When you need the **maximum sum of a contiguous subarray** in a 1D array â€” especially when the array may contain negative values.
* **Mistakes to Avoid:**
  * Forgetting to reset the current sum when it goes negative
  * Not initializing with the first element (especially when all elements are negative)

---

## ðŸ”¹ Optimization Path

* **Brute Force:** O(nÂ²) â€” Try every subarray and track the max sum
* **Optimized Solution:** O(n) â€” Use Kadaneâ€™s Algorithm
* **Further Improvements Possible?**
  Already optimal for time and space.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** At each index, decide whether to extend the subarray or start a new one
* **Why This Works?**
  A negative running sum **hurts** the total â€” so itâ€™s better to start over when it drops below 0
* **Edge Cases Considered:**
  * All negative numbers
  * Single-element array
  * Zeros between positives and negatives

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:**
  ðŸ”¹ Kadaneâ€™s Algorithm
  ðŸ”¹ Dynamic Programming
* **Common Problems Using This:**
  * Maximum Product Subarray
  * Circular Maximum Subarray
  * Contiguous Subarrays with Constraints

---

## ðŸ”¹ Tricks & Patterns Used

* **Kadaneâ€™s Algorithm**
* **Greedy-DP Hybrid:** Decision at each index â€” continue or restart
* Avoided extra space by using 2 variables

---

## ðŸ”¹ Alternative Data Structures

* None needed; this is a pure array traversal problem.

---

## ðŸ”¹ Complexity Analysis


| Metric               | Value                             |
| -------------------- | --------------------------------- |
| **Time Complexity**  | O(n) â€” single pass through array |
| **Space Complexity** | O(1) â€” constant extra variables  |

---

## ðŸ”¹ Code Snippet (Optimized)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        maxSub = nums[0]    # Stores the global max subarray sum
        curSum = 0          # Tracks current subarray sum

        for num in nums:
            if curSum < 0:
                curSum = 0  # Reset if current sum goes negative
            curSum += num   # Add current number to the running sum
            maxSub = max(maxSub, curSum)  # Update global max if needed

        return maxSub

```
