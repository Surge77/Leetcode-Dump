# ğŸ”¹ Problem Name: 73. Set Matrix Zeroes (Array/Matrix, Medium)

**ğŸ”— Link:** [73. Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)
**ğŸŸ¢ Status:** âœ… Solved

---

## ğŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Detect zeros first, then zero out corresponding rows/columns without letting newly written zeros cascade.
* **Core Concept:** Row/Column **marking** â€” either with auxiliary arrays (O(m+n) space) or by **hijacking the first row/column** as markers (O(1) space).
* **When to Use This Pattern?** When a matrixâ€™s row/column needs a bulk transformation based on cell predicates but in-place constraints forbid naive multi-pass mutation.
* **Mistakes to Avoid (cm):**
  * Mutating while scanning â†’ causes zero â€œinfection.â€
  * Forgetting to handle first row/column separately in O(1) approach.
  * Misusing `matrix[0][0]` (dual-purpose marker) without a separate flag.

---

## ğŸ”¹ Optimization Path

* **Brute Force:** For each zero, traverse entire row and column immediately â†’ O(kÂ·(m+n)) and risk cascading if done in-place incorrectly.
* **Optimized Solution A (Marker Arrays):** Use `rows[m]`, `cols[n]` boolean arrays. Time O(mn), Space O(m+n).
* **Optimized Solution B (Edge Hijacking):** Use first row/col as markers. Time O(mn), **Space O(1)**.

---

## ğŸ”¹ Solution Breakdown

### Optimal Approach (Space-Optimal, O(1) Space)

* **Idea:** First pass: mark columns in `matrix[0][c]` and rows in `matrix[r][0]`. Keep a `rowZero` flag for whether the **first row** originally had a zero. Second pass: zero inner cells based on markers. Finally, zero first column if `matrix[0][0]==0` and first row if `rowZero`.
* **Why This Works?** It separates **detection** (markers) from **transformation**, while storing metadata **in the matrix itself**. Flags prevent clobbering marker state for row 0/col 0.
* **Edge Cases Considered:** 1Ã—1 matrix, zeros in first row, zeros in first column, all-zero matrix, no-zero matrix.

---

## ğŸ”¹ Pattern Recognition

* **Belongs To:** Array/Matrix â€” **In-place Marking** (a common trick family with constant-space metadata).
* **Common Problems Using This:**
  * Game of Life (in-place state encoding)
  * Image/Matrix rotations with minimal extra space
  * Spreadsheet-like propagation constraints

---

## ğŸ”¹ Tricks & Patterns Used

* **Bit/Flag Markers:** Use boundary row/col as metadata.
* **Two-Phase Transform:** (1) Mark, (2) Apply.
* **Sentinel Flags:** Handle `matrix[0][0]` ambiguity with a separate boolean (`rowZero`).

---

## ğŸ”¹ Alternative Data Structures

* **With Extra Space:** Boolean arrays `rows[m]`, `cols[n]` give simpler logic at cost of O(m+n) space.
* **Why Not Hash Sets?** Equivalent to boolean arrays functionally; arrays are simpler/faster and space-predictable.

---

## ğŸ”¹ Complexity Analysis

* **Time Complexity:** O(mÂ·n) â€” each cell is visited a constant number of times.
* **Space Complexity:**
  * **O(1)** for the edge-hijacking approach (only a couple of booleans).
  * **O(m+n)** for the marker-arrays approach.

---

## ğŸ”¹ Code Snippet (Optimized â€” O(1) Space)

```python
# Time: O(m*n)
# Space: O(1)
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        ROWS, COLS = len(matrix), len(matrix[0])
        rowZero = False  # Did the first row originally contain a zero?

        # Phase 1: Mark columns using first row; mark rows using first column
        for r in range(ROWS):
            for c in range(COLS):
                if matrix[r][c] == 0:
                    matrix[0][c] = 0
                    if r > 0:
                        matrix[r][0] = 0
                    else:
                        rowZero = True

        # Phase 2: Apply zeros to inner matrix using markers
        for r in range(1, ROWS):
            for c in range(1, COLS):
                if matrix[0][c] == 0 or matrix[r][0] == 0:
                    matrix[r][c] = 0

        # Phase 3: First column
        if matrix[0][0] == 0:
            for r in range(ROWS):
                matrix[r][0] = 0

        # Phase 4: First row
        if rowZero:
            for c in range(COLS):
                matrix[0][c] = 0
```

---

## ğŸ”¹ Code Snippet (Marker Arrays â€” O(m+n) Space)

```python
# Time: O(m*n)
# Space: O(m+n)
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        ROWS, COLS = len(matrix), len(matrix[0])
        rows = [False] * ROWS
        cols = [False] * COLS

        # Pass 1: record which rows/cols need zeroing
        for r in range(ROWS):
            for c in range(COLS):
                if matrix[r][c] == 0:
                    rows[r] = True
                    cols[c] = True

        # Pass 2: apply zeroing
        for r in range(ROWS):
            for c in range(COLS):
                if rows[r] or cols[c]:
                    matrix[r][c] = 0
```

---

## ğŸ”¹ Common Misconceptions (cm)

* **â€œI can zero on the fly during scan.â€** â†’ New zeros will falsely trigger more rows/cols. Always separate mark vs. apply.
* **â€œ`matrix[0][0]` only marks the first row.â€** â†’ It collides with first column too; use a separate `rowZero` flag.
* **â€œO(1) space is always faster.â€** â†’ Logic is trickier; on interviews itâ€™s favored, but in practice, O(m+n) with clarity may be fine.

---

## ğŸ”¹ Edge Cases Handled

* Single cell matrices (1Ã—1)
* All-zero or zero-free matrices
* Zeros in the first row or first column
* Very wide/tall matrices (stress markers and iteration order)

---

## ğŸ”¹ Interview Tips

* State the **two-phase** plan up front.
* Call out the **`matrix[0][0]` ambiguity** and the `rowZero` flag explicitly.
* Implement the O(m+n) version first, then upgrade to O(1) if time allows.
