# ðŸ”¹ Problem Name: Evaluate Reverse Polish Notation (Stack, Medium)

**ðŸ”— Link:** [LeetCode 150 - Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Stack-based evaluation
* **Core Concept:** Reverse Polish Notation eliminates precedence rules, allowing single-pass evaluation with LIFO operand handling.
* **When to Use This Pattern?** When operators are provided *after* operands and evaluation order is explicit (RPN/Postfix problems).
* **Mistakes to Avoid:** Forgetting operand order for subtraction/division; mixing integer truncation rules.

## ðŸ”¹ Optimization Path

* **Brute Force:** Recursively slice the array and evaluate subexpressions â†’ O(n^2) due to repeated list reconstruction.
* **Optimized Solution:** Stack-based evaluation â†’ O(n) time, O(n) space.
* **Further Improvements Possible?** No major optimizations; RPN evaluation is already optimal at O(n) with a stack.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Iterate through tokens; push operands onto the stack; on encountering an operator, pop required operands, apply the operation, push the result back.
* **Why This Works?** RPN guarantees operands appear before their operator, making it naturally compatible with stack processing.
* **Edge Cases Considered:** Division truncation toward zero; non-commutative operator order (subtraction/division); minimal expression with a single operand.

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Stack pattern (Expression Evaluation)
* **Common Problems Using This:** Basic Calculator I/II/III, Infix to Postfix conversion, Simplify Path, Decode String.

## ðŸ”¹ Tricks & Patterns Used

* **Stack for Operand Storage**
* **Order Handling for Non-Commutative Operators**
* **Commutative Operation Optimization**

## ðŸ”¹ Alternative Data Structures

* Could theoretically use a deque, but stack (list) is simplest and most natural fit.

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) â€” single pass through tokens, each operation O(1)
* **Space Complexity:** O(n) â€” stores operands in stack until processed

## ðŸ”¹ Code Snippet (Optimized)

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []  # LIFO structure perfectly matches RPN semantics
    
        for c in tokens:
            if c == "+":
                stack.append(stack.pop() + stack.pop())  # Commutative
            elif c == "-":
                a, b = stack.pop(), stack.pop()
                stack.append(b - a)  # Non-commutative
            elif c == "*":
                stack.append(stack.pop() * stack.pop())  # Commutative
            elif c == "/":
                a, b = stack.pop(), stack.pop()
                stack.append(int(float(b) / a))  # Truncate toward zero
            else:
                stack.append(int(c))  # Push operand
            
        return stack[0]  # Final result

# Complexity:
# Time: O(n)
# Space: O(n)
```
