# ğŸ”¹ Problem Name: Design Circular Queue (Queue, Medium)

**ğŸ”— Link:** [622. Design Circular Queue](https://leetcode.com/problems/design-circular-queue/)
**ğŸŸ¢ Status:** ğŸ”„ Need Review

---

## ğŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Fixed-size **circular buffer** with **size-tracking** (compute rear as `(head + count - 1) % k`)
* **Core Concept:** **Modulo wrap-around** + pointer math for true O(1) ops
* **When to Use This Pattern?** Bounded FIFO queues where memory must be predictable (I/O rings, streams, embedded).
* **Mistakes to Avoid (cm):**

  * Confusing **full vs empty** when only using `head==tail`; fix via **count** or one-slot-empty rule.
  * Shifting elements on dequeue (kills O(1)).
  * Wrong rear index formula (off-by-one at wrap).
  * Forgetting to `% capacity` on both `head` advance and rear calc.

---

## ğŸ”¹ Optimization Path

* **Brute Force:** Array queue with shifting on every dequeue â†’ **O(n)** per `deQueue`.
* **Optimized Solution:** Circular buffer; maintain `head` + `count`; compute positions with modulo â†’ **O(1)** for all ops.
* **Further Improvements Possible?**

  * **Power-of-two capacity** â†’ replace `% k` with bitmask `& (k-1)`.
  * **Resizable ring** for unbounded workloads (copy into 2Ã— buffer when full).

---

## ğŸ”¹ Solution Breakdown

* **Optimal Approach:** Keep `queue[k]`, `head`, and `count`.

  * Enqueue at `(head + count) % k`, increment `count`.
  * Dequeue by advancing `head = (head + 1) % k` and decrementing `count`.
* **Why This Works?** Treating the array as a **ring** avoids data movement; modulo math reuses freed slots; `count` disambiguates empty vs full.
* **Edge Cases Considered:** capacity=1, repeated wrap-around, alternating enqueue/dequeue, queries on empty/full states.

---

## ğŸ”¹ Pattern Recognition

* **Belongs To:** Queue / **Circular Buffer** (Ring Buffer).
* **Common Problems Using This:** Rate limiters, producerâ€“consumer buffers, NIC RX/TX rings, audio streaming buffers.

---

## ğŸ”¹ Tricks & Patterns Used

* **Modulo Wrap-Around** for index safety and reuse.
* **Size-Tracked Design** (`count`) to avoid full/empty ambiguity.
* **O(1) pointer moves** instead of O(n) shifts.

---

## ğŸ”¹ Alternative Data Structures

* **Linked-list queue** (unbounded, worse cache locality).
* **`collections.deque`** (built-in double-ended queue) if constraints allow.
* **Two-stack queue** (when only stacks are allowed, amortized O(1)).

---

## ğŸ”¹ Complexity Analysis

* **Time Complexity:** `enQueue`, `deQueue`, `Front`, `Rear`, `isEmpty`, `isFull` â†’ **O(1)** each.
* **Space Complexity:** **O(k)** fixed array.

---

## ğŸ”¹ Code Snippet (Optimized)

```python
class MyCircularQueue:
    """
    Fixed-capacity circular queue (ring buffer) using size tracking.

    Complexity per operation:
      - enQueue, deQueue, Front, Rear, isEmpty, isFull: O(1)
    Space: O(k) for capacity k.
    """

    def __init__(self, k: int):
        assert k > 0, "Capacity must be positive."
        self.queue = [0] * k   # Fixed-size buffer
        self.capacity = k
        self.head = 0          # Index of front element (valid when count>0)
        self.count = 0         # Number of elements currently stored

    def enQueue(self, value: int) -> bool:
        """Insert at rear. Return True if success, False if full.  O(1)."""
        if self.count == self.capacity:
            return False
        tail = (self.head + self.count) % self.capacity
        self.queue[tail] = value
        self.count += 1
        return True

    def deQueue(self) -> bool:
        """Remove front. Return True if success, False if empty.  O(1)."""
        if self.count == 0:
            return False
        # Optional: clear slot for GC/clarity â†’ self.queue[self.head] = 0
        self.head = (self.head + 1) % self.capacity
        self.count -= 1
        return True

    def Front(self) -> int:
        """Return front element or -1 if empty.  O(1)."""
        if self.count == 0:
            return -1
        return self.queue[self.head]

    def Rear(self) -> int:
        """Return rear element or -1 if empty.  O(1)."""
        if self.count == 0:
            return -1
        rear_index = (self.head + self.count - 1) % self.capacity
        return self.queue[rear_index]

    def isEmpty(self) -> bool:
        return self.count == 0

    def isFull(self) -> bool:
        return self.count == self.capacity
```

---
