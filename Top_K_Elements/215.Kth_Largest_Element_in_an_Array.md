# ðŸ”¹ Problem Name: Kth Largest Element in an Array (Top-K / Heaps, Medium)

**ðŸ”— Link:** [LeetCode 215](https://leetcode.com/problems/kth-largest-element-in-an-array/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Maintain a **min-heap of size k** that stores the k largest elements seen so far.
* **Core Concept:****Top-K Elements (Heaps)** â€” keep only what you need; the heap root is the current k-th largest.
* **When to Use This Pattern?** When you need the **k-th largest/smallest** and **k â‰ª n**, or when data streams in and you need an ongoing top-k.
* **Mistakes to Avoid:**
  * Off-by-one with `k` (ensure heap size is **exactly** k).
  * Using a **max-heap** in Pythonâ€™s `heapq` (itâ€™s a **min-heap**; for k-th largest, keep size k and compare to `heap[0]`).
  * Doing full sort (O(n log n)) when O(n log k) suffices.
  * Using `heappush` + `heappop` separately instead of `heapreplace`/`heappushpop` for efficiency.

## ðŸ”¹ Optimization Path

* **Brute Force:** Sort descending and pick k-th â†’ **O(n log n)** time, **O(1)** extra space (if in-place).
* **Optimized Solution (This):****Min-heap of size k** â†’ **O(n log k)** time, **O(k)** space.
* **Further Improvements Possible?**
  * **Quickselect (average O(n))**, worst-case O(nÂ²), in-place; great when you can accept average-case and want lower constants.
  * **Partial heapify:** Build heap from first k in **O(k)**, then scan rest with `heapreplace`.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Keep a min-heap of size k; push the first k numbers, then for each remaining number `x`, if `x > heap[0]` replace root.
* **Why This Works?** The heap always contains the **k largest** seen so far; the smallest among them (heap root) is the **k-th largest overall** once all items are processed.
* **Edge Cases Considered:**
  * `k = 1` â†’ answer is `max(nums)`.
  * `k = n` â†’ answer is `min(nums)`.
  * Duplicates / negatives â€” handled naturally by the comparisons.
  * Very small arrays (n < 3) â€” logic remains identical.

## ðŸ”¹ Pattern Recognition

* Belongs To:**Top-K Elements (Heaps)** (Pattern #9 in your list).
* **Common Problems Using This:**
  * Top K Frequent Elements
  * Kth Smallest in a Sorted Matrix
  * Merge K Sorted Lists
  * Find Median from Data Stream (two heaps)

## ðŸ”¹ Tricks & Patterns Used

* Maintain a **fixed-size min-heap (k)**; compare new elements to `heap[0]`.
* Prefer `heapq.heapreplace(heap, x)` over `heappop` + `heappush` (1 sift vs 2).
* For streams, process incrementally â€” the heap is your rolling state.

## ðŸ”¹ Alternative Data Structures

* **Max-heap via negation** (store `-x`) â€” pop `k-1` and return `-heap[0]` (more memory, good if you need many pops).
* **Order-statistics tree** (not in Python stdlib) â€” supports k-th queries; overkill here.
* **Quickselect** (no heap) â€” average O(n) when you can mutate in-place.

## ðŸ”¹ Complexity Analysis

* Time Complexity:**O(n log k)** â€” each of n elements may trigger a heap operation in O(log k).
* Space Complexity:**O(k)** â€” heap stores at most k elements.

## ðŸ”¹ Code Snippet (Optimized)

```python

class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        """
        Return the k-th largest element using a min-heap of size k.
        Keep the k largest elements; the heap root is the k-th largest.
        """
        # Build a min-heap using the first k elements: O(k)
        heap = nums[:k]
        heapq.heapify(heap)

        # Process the rest: for each x, if x is larger than the smallest in heap,
        # it belongs in the top-k â†’ replace root (single sift): O((n-k) log k)
        for x in nums[k:]:
            if x > heap[0]:
                heapq.heapreplace(heap, x)  # faster than heappop + heappush

        return heap[0]  # The k-th largest

# Time Complexity: O(n log k)
#   - heapify first k in O(k)
#   - iterate remaining (n-k) with O(log k) replace operations
# Space Complexity: O(k) for the heap
```
