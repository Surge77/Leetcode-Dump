# ðŸ”¹ Problem Name: Valid Parentheses (Stack Matching, Easy)

**ðŸ”— Link:** [LeetCode 20 â€” Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Use a stack (LIFO). Push opens, on close check top and pop.
* **Core Concept:** Stack Matching with a hash map for O(1) pairing.
* **When to Use This Pattern?**

  * You must validate **properly nested** pairs with **reverse closure order** (last opened closes first).
* **Mistakes to Avoid (cm):**

  * Forgetting to check for **empty stack** before popping on a closing bracket.
  * Accepting strings where **leftovers remain in stack** at the end.
  * Using many `if/elif` chains instead of a **map** for pairing.
  * Treating non-bracket chars as valid (this problem only has `()[]{}`).

## ðŸ”¹ Optimization Path

* **Brute Force:** Continuously remove `()` / `[]` / `{}` pairs until none remain. **O(n^2)** time, multiple passes.
* **Optimized Solution:** Stack + Hash Map lookup, **O(n)** time, **O(n)** space.
* **Further Improvements Possible?** No â€” this is already optimal for sequential processing.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Maintain a stack for opening brackets; when encountering a closing bracket, check if it matches the top of the stack. If yes, pop; else, return `False`. At the end, return `True` if the stack is empty.
* **Why This Works?** The LIFO nature of stacks matches the requirement for nested parentheses validation.
* **Edge Cases Considered:**

  * Empty string (valid)
  * Starts with a closing bracket (invalid)
  * Contains only one bracket (invalid)
  * Nested but mismatched brackets like `([)]` (invalid)

## ðŸ”¹ Pattern Recognition

* **Belongs To:** **Monotonic Stack / Queue** (subpattern: Stack Matching)
* **Common Problems Using This:**

  * Min Remove to Make Valid Parentheses
  * HTML/XML tag validator
  * Decode String
  * Balanced Brackets variations

## ðŸ”¹ Tricks & Patterns Used

* **Stack for LIFO ordering**
* **Hash Map for O(1) matching**
* **Immediate validation** on encountering closing bracket

## ðŸ”¹ Alternative Data Structures

* **Deque** could be used instead of list for stack operations (but Python list is sufficient here).
* Using **array indexing** instead of stack is possible but less intuitive.

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) â€” single pass, each push/pop is O(1).
* **Space Complexity:** O(n) â€” worst case all opening brackets in stack.

## ðŸ”¹ Code Snippet (Optimized)

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []  # LIFO for opening brackets
        closeToOpen = {")": "(", "]": "[", "}": "{"}  # Matching pairs

        for c in s:
            if c in closeToOpen:  # Closing bracket
                if stack and stack[-1] == closeToOpen[c]:
                    stack.pop()  # Match found
                else:
                    return False  # Mismatch or empty stack
            else:
                stack.append(c)  # Opening bracket

        return not stack  # Valid if stack empty

# Complexity:
# Time: O(n) â€” Single traversal, O(1) push/pop.
# Space: O(n) â€” Stack can hold up to n/2 opening brackets.
```

---

**Interview Power Move:**

> "I recognized the LIFO nature of valid parentheses and used a stack to track opening brackets, validating each closing bracket immediately. A hash map provides O(1) type lookup, making it clean and extensible. This yields O(n) time and O(n) space with a single pass."
