## 🚀 **1. First Principles Thinking (FPT)**

💡 **What it is:** Breaking down the problem into fundamental truths and reasoning up from there.
🎯 **Use it for:** Deep insights, root cause analysis, and conceptual clarity.

📌 **How to prompt:**

> "Explain this code using **First Principles Thinking (FPT)**—break it down to its most fundamental concepts, avoid analogies, and reconstruct it logically."

✅ **Example:**
🔹 Given an algorithm, break it down into **core operations (loops, conditions, data structures)** and analyze its behavior at the most atomic level.

---

## 🏗 **2. Step-by-Step Execution (Dry Run)**

💡 **What it is:** Simulating how the code executes **line by line** with sample input.
🎯 **Use it for:** Debugging, visualization, and understanding loops/conditions.

📌 **How to prompt:**

> "Walk through this code **step by step** with an example input and show how the variables change at each step."

✅ **Example:**
🔹 Given an array-processing algorithm, show how **each iteration updates variables** in a table format.

---

## 🎭 **3. Pattern Recognition & Analogies**

💡 **What it is:** Relating the code to **common problem-solving patterns** or real-world analogies.
🎯 **Use it for:** Recognizing repeated problem structures, high-level intuition.

📌 **How to prompt:**

> "Compare this code to a **real-world analogy** and explain how it follows common patterns like DP, Sliding Window, etc."

✅ **Example:**
🔹 Explaining **binary search** using a **dictionary lookup analogy** or explaining **recursion** using **Russian dolls.**

---

## 🔍 **4. Time Complexity & Optimization Path**

💡 **What it is:** Understanding **how the code scales** and if there’s a **better approach.**
🎯 **Use it for:** Performance tuning, algorithmic efficiency.

📌 **How to prompt:**

> "Break down the **time and space complexity** of this code, identify the bottlenecks, and suggest optimizations."

✅ **Example:**
🔹 Given an **O(n²) brute-force** algorithm, check if **sorting or data structures** can reduce it to **O(n log n) or O(n).**

---

## 🛠 **5. Code Deconstruction (Explain Like I’m 5 - ELI5)**

💡 **What it is:****Breaking down complex code into simple, beginner-friendly chunks.**
🎯 **Use it for:****Grasping new topics, intuitive learning, and quick understanding.**

📌 **How to prompt:**

> "Explain this code like I’m 5 (ELI5) using **simple terms, metaphors, and clear logic.**"

✅ **Example:**
🔹 Explaining recursion as **a chef following a recipe and calling another chef when stuck.**

---

## 🏎 **6. Edge Cases & Failure Scenarios**

💡 **What it is:** Stress-testing the code with **edge cases** to understand where it breaks.
🎯 **Use it for:** Finding weaknesses, debugging.

📌 **How to prompt:**

> "What are the edge cases for this code? How does it behave in worst-case scenarios?"

✅ **Example:**
🔹 Checking if an **array-sorting algorithm** handles **duplicates, empty inputs, or large numbers.**

---

## 🧩 **7. Comparative Analysis (Alternative Approaches)**

💡 **What it is:** Comparing multiple ways to solve the same problem and choosing the best.
🎯 **Use it for:** Evaluating different approaches.

📌 **How to prompt:**

> "Explain this approach vs. [brute force / DP / greedy / two pointers] and compare their strengths/weaknesses."

✅ **Example:**
🔹 Comparing **brute force vs. DP for Fibonacci**, showing how **memoization reduces redundant computations.**

---

## 🔥 **How to Use These for Elite-Level Explanations?**

Whenever you request an explanation, **combine multiple frameworks** for **maximum clarity.**

📌 **Example Prompt for an Elite Explanation:**

> "Explain this code using:
>
> * **FPT** to break it into fundamentals,
> * **Step-by-step execution** with an example,
> * **Pattern recognition** to relate it to common problems,
> * **Complexity analysis** to check performance,
> * **Alternative approaches** for comparison."
>
