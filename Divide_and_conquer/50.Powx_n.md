# 🔹 Problem Name: Pow(x, n) (Math/Divide & Conquer, Medium)

**🔗 Link:** [LeetCode 50 — Pow(x, n)](https://leetcode.com/problems/powx-n/)
**🟢 Status:** ✅ Solved

---

## 🔹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Recursive Fast Exponentiation (Divide & Conquer).
* **Core Concept:** Use the identity:

  * If `n` is even → $x^n = (x^2)^{n/2}$.
  * If `n` is odd → $x^n = x * (x^2)^{n/2}$.
* **When to Use This Pattern?**
  When dealing with large exponents where multiplying `x` n times (O(n)) is too slow. This is especially critical in competitive programming, cryptography, or modular arithmetic problems.
* **Mistakes to Avoid:**

  1. Forgetting to handle negative powers (invert result).
  2. Missing the base case for `n=0` (should return 1).
  3. Mishandling zero base (`x=0`).

---

## 🔹 Optimization Path

* **Brute Force:** Multiply `x` repeatedly `n` times.
  **Time:** O(|n|)
  **Space:** O(1)
* **Optimized Solution (Recursive Fast Pow):** Halve exponent each call.
  **Time:** O(log |n|)
  **Space:** O(log |n|) — recursion stack.
* **Further Improvements Possible?**

  * Iterative fast power version avoids recursion depth → **Space O(1)**.
  * Modular exponentiation variant for cryptography & large number handling.
    Ref: [Modular exponentiation (Wikipedia)](https://en.wikipedia.org/wiki/Modular_exponentiation)

---

## 🔹 Solution Breakdown

* **Optimal Approach:** Recursively apply exponent halving, square `x` each time, multiply by extra `x` when exponent is odd.
* **Why This Works?** Every step reduces problem size by ~50%. Even exponent reduces cleanly, odd exponent leaves a factor of `x`.
* **Edge Cases Considered:** 0 exponent, 0 base with positive exponent, negative exponents, large |n|.

---

## 🔹 Pattern Recognition

* **Belongs To:** Divide & Conquer (recursion on halves).
* **Common Problems Using This:**

  * [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/) — binary search / power check.
  * Modular exponentiation (for RSA, Diffie-Hellman).
  * Fast Fibonacci computation with matrix exponentiation.

---

## 🔹 Tricks & Patterns Used

* **Divide & Conquer:** Halve exponent at each step.
* **Negative Exponent Handling:** Compute positive power, invert at end.
* **Tailor for Iteration:** Convert recursion into loop for O(1) space.

---

## 🔹 Alternative Data Structures

* Not applicable — problem is numeric.
* **Mathematical Optimization:** Iterative fast exponentiation, modular variant for cryptography.

---

## 🔹 Complexity Analysis

* **Time Complexity:** O(log |n|) — halve exponent each step.
* **Space Complexity:** O(log |n|) recursion depth (can be reduced to O(1) with iterative approach).

---

## 🔹 Code Snippet (Optimized — Recursive Fast Pow)

```python
# Time: O(log |n|)
# Space: O(log |n|)
class Solution:
    def myPow(self, x: float, n: int) -> float:
        def helper(x, n):
            if x == 0:
                return 0
            if n == 0:
                return 1
            res = helper(x * x, n // 2)
            return x * res if n % 2 else res

        res = helper(x, abs(n))
        return res if n >= 0 else 1 / res
```

<details>
<summary>Alternate: Iterative Fast Exponentiation (O(1) space)</summary>

```python
# Time: O(log |n|)
# Space: O(1)
class Solution:
    def myPow(self, x: float, n: int) -> float:
        N = abs(n)
        result = 1.0
        while N:
            if N % 2:
                result *= x
            x *= x
            N //= 2
        return result if n >= 0 else 1 / result
```

</details>

---

## 🔹 Common Misconceptions (cm)

* **“Must multiply x n times.”** Linear approach is too slow for large n.
* **“Negative powers aren’t different.”** They require inversion at the end.
* **“Recursion always overflows.”** With log n depth, recursion is safe for most constraints, but iterative is safer.

---

## 🔹 80/20 (8ty)

* The 20% that gives 80% wins:

  1. Halve the exponent each iteration.
  2. Handle negative exponents by reciprocal.
  3. Use iterative version for O(1) space.

---

## 🔹 Related Reading

* [Divide and Conquer Algorithms](https://cp-algorithms.com/algebra/binary-exp.html)
* [Exponentiation by Squaring (Wikipedia)](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)

---

## 🔹 Test Trace Example (x=2.0, n=5)

* Call: helper(2,5)
* → helper(4,2)
* → helper(16,1) → helper(256,0) = 1
* backtrack: 16^1 = 16 → multiply extra 2 → 32.
* Result = 32.

---

## 🔹 Interview Power Move

> “Exponentiation by squaring reduces multiplications from O(n) to O(log n). Handle negatives by reciprocal and use iterative version for O(1) space.”
