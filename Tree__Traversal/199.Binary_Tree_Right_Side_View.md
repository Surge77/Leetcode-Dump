# 🔹 **Problem Overview**

**Title:** [Binary Tree Right Side View (LeetCode 199)](https://leetcode.com/problems/binary-tree-right-side-view/)

**Difficulty:** 🟡 Medium

**Date Solved:** 2025-10-22

**Status:** ✅ Solved

---

## 🔹 **Step 1 — Problem Understanding**

**In My Own Words:**

Given a binary tree, return the values of the nodes you can see when viewing it from the right side — i.e., the last node at each level.

**Input → Output Mapping:**

Binary Tree → List[int] (each element = rightmost node at each level).

**Constraints:**

* Node count n ∈ [0, 10^4]
* Node values: integers (can be negative or positive)
* Tree may be skewed or balanced
* Time: O(n) expected; must handle empty tree safely

**Edge Cases Identified:**

* Empty tree → []
* Single node → [root.val]
* Left-skewed tree → top to bottom values
* Right-skewed tree → identical to root-to-leaf path
* Null children in mixed subtrees

---

## 🔹 **Step 2 — Core Thinking Process**

**1. Pattern Recognition:**

* **15patterns:** Tree Traversal → Level-order BFS pattern
* Goal is to isolate each level and capture the rightmost element.

**2. Brute Force Idea:**

* Traverse all nodes and store per-level arrays, then take last element from each level list.

**3. Optimization Trigger:**

* Observation: You don’t need to store entire levels. Track the *last* node processed per level using queue length.

**4. Chosen Approach:**

* **BFS Level-order Traversal:** Process nodes level by level using a queue, capturing the last node in each level.

**5. Algorithm Steps (Pseudo-Logic):**

```
Initialize res = []
Initialize queue = [root]
While queue not empty:
    levelSize = len(queue)
    rightmost = None
    for each node in current level:
        node = queue.popLeft()
        if node exists:
            rightmost = node
            queue.append(node.left)
            queue.append(node.right)
    if rightmost exists:
        res.append(rightmost.val)
Return res
```

---

## 🔹 **Step 3 — Implementation**

**Optimized Code:**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque
from typing import Optional, List

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        q = deque([root])

        while q:
            rightSide = None
            qLen = len(q)

            for i in range(qLen):
                node = q.popleft()
                if node:
                    rightSide = node
                    q.append(node.left)
                    q.append(node.right)

            if rightSide:
                res.append(rightSide.val)
        return res
```

**Time Complexity:** O(n) — each node is processed once.

**Space Complexity:** O(w) — proportional to the maximum width of the tree.

**Edge Cases Handled:** ✅ Empty, skewed, null children, unbalanced trees.

---

## 🔹 **Step 4 — Reflection**

**Why This Works:**

BFS naturally explores level by level, so the last node processed in each level is the rightmost visible one.

**Common Misconceptions (cm):**

* [X]  Need to traverse right children first → unnecessary; BFS order suffices.
* [X]  Must store full levels → only last node matters.
* [X]  Null handling ignored → must check before enqueuing.

**Optimization Opportunities:**

* **DFS alternative:** Right-first traversal with depth tracking (same O(n), less intuitive for wide trees).
* **Space tuning:** Skip appending nulls to queue to reduce space.

---

## 🔹 **Step 5 — Pattern Journal**

**Belongs To Pattern:** Level-order BFS Traversal

**Trigger Words to Recognize Next Time:** “right side view”, “visible from right”, “level order”, “rightmost per level”

**Related Problems:**

* Binary Tree Level Order Traversal (LeetCode 102)
* Left Side View of Binary Tree (variation)
* Binary Tree Zigzag Level Order Traversal (LeetCode 103)

**Generalized Formula / Idea:**

* Any *side view* can be solved using level-order traversal by capturing either the first (left view) or last (right view) node at each level.

---

## 🔹 **Step 6 — Learning Notes**

**What I Learned (in one line):**

> Level-wise BFS with queue length = cleanest way to isolate visible nodes per level.

**What Tripped Me Up:**

> Initially thought right child must be processed first — not true for BFS.

**How I’ll Recognize This Pattern Faster Next Time:**

> Any mention of “per level” or “view” instantly signals BFS pattern.

---

## 🔹 **Step 7 — Meta Tags**

**Topic Tags:** Tree / BFS / Queue / Level Traversal

**Pattern Type:** BFS (15patterns #10 — Tree Traversal)

**Data Structures Used:** Deque (queue), Binary Tree

**Review Frequency:** 🔁 Weekly

**Confidence Level:** 💪 High

---

## 🔹 **Step 8 — Snapshot Summary**

**Problem in One Line:**

> Find the rightmost node at each depth using BFS.

**Solution in One Line:**

> BFS traversal; capture the last node per level.

**Pattern Keyword (for search):**

> Tree_RightSideView_BFS

---

## 🔹 **Step 9 — Version History**


| Version | Change                                     | Date       | Status |
| ------- | ------------------------------------------ | ---------- | ------ |
| v1.0    | Initial BFS-based solution                 | 2025-10-22 | ✅     |
| v1.1    | Added DFS comparison and optimization note | 2025-10-22 | 🔄     |

---

## 🔹 **Step 10 — Final Reflection Prompt**

> 🧩 Between BFS and DFS for side view, which scales better for wide vs. deep trees, and how does this influence recursion safety and memory tradeoffs?
