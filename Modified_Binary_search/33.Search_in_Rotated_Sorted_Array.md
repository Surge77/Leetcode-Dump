# ðŸ”¹ Problem Name: Search in Rotated Sorted Array (Binary Search, Medium)

**ðŸ”— Link:** [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Modified Binary Search (detect sorted half at each step)
* **Core Concept:** Divide & Conquer, Two Pointers, Conditional Branching
* **When to Use This Pattern?**
  * Array is sorted but rotated at an unknown pivot
  * Need O(log n) search
* **Mistakes to Avoid:**
  * Not handling boundary updates (`l` and `r`) correctly
  * Off-by-one errors (e.g., infinite loop or missing target)
  * Incorrectly checking sorted halves (mixing up indices)

## ðŸ”¹ Optimization Path

* **Brute Force:** O(n) â€” Scan array linearly
* **Optimized Solution:** O(log n) â€” Modified Binary Search
* **Further Improvements Possible?**
  * No; O(log n) is optimal for search in rotated, sorted array without duplicates

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** At each step, identify the sorted half. If the target lies in that sorted range, continue there; else, search the other half.
* **Why This Works?** The rotation guarantees at least one half of the array is sorted. By leveraging this, we can confidently reduce the search space by half each time, maintaining logarithmic time.
* **Edge Cases Considered:**
  * Target not present
  * Pivot at first or last element
  * Small arrays (size 1 or 2)
  * Duplicates not present (for LeetCode 33)

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Modified Binary Search, Two Pointers, Divide & Conquer
* **Common Problems Using This:**
  * Search in Rotated Sorted Array II (with duplicates)
  * Find Minimum in Rotated Sorted Array
  * Find Peak Element
  * Binary Search Variants

## ðŸ”¹ Tricks & Patterns Used

* Detecting sorted half with `nums[l] <= nums[mid]`
* Smart pointer updates to shrink search space
* Avoiding mid calculation overflow (in other languages)

## ðŸ”¹ Alternative Data Structures

* Not applicable; array is required. No faster DS for this problem in-place.

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(log n) â€” Each iteration halves the search space.
* **Space Complexity:** O(1) â€” No extra space used, only pointers and variables.

## ðŸ”¹ Code Snippet (Optimized)

```python
from typing import List

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:
            mid = (l + r) // 2
            if target == nums[mid]:
                return mid

            # Identify which half is sorted
            if nums[l] <= nums[mid]:
                # Left half is sorted
                if target > nums[mid] or target < nums[l]:
                    l = mid + 1
                else:
                    r = mid - 1
            else:
                # Right half is sorted
                if target < nums[mid] or target > nums[r]:
                    r = mid - 1
                else:
                    l = mid + 1
        return -1

# Time Complexity: O(log n)
# Space Complexity: O(1)
# Edge cases and common pitfalls handled: pointer update logic, single-element arrays, boundaries
```
