# ðŸ”¹ Problem Name: Basic Calculator II (Parsing / Stack, Medium)

**ðŸ”— Link:** [LeetCode 227: Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** One-pass parser with precedence handling using a stack or O(1) `last_term` trick.
* **Core Concept:** Expression evaluation with operator precedence (`*`/`/` > `+`/`-`) and truncation toward zero.
* **When to Use This Pattern?** When evaluating arithmetic strings without parentheses and with standard precedence.
* **Mistakes to Avoid:**

    * Using Python `//` for division (floors) instead of **truncate toward zero** (`int(a/b)`).
    * Forgetting to process the **last number** at end-of-string.
    * Pushing operators to the stack (we store **terms**, not operators).

## ðŸ”¹ Optimization Path

* **Brute Force:** Convert infix â†’ postfix (Shunting-yard) â†’ evaluate. **Time:** O(n), **Space:** O(n) (two passes, heavier parsing).
* **Optimized Solution:** Single pass; stack for terms or O(1) `last_term` + `total`. **Time:** O(n), **Space:** O(1) or O(n) depending on variant.
* **Further Improvements Possible?** Minor: micro-opt for skipping whitespace and early returns; otherwise optimal for constraints.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Scan leftâ†’right, build `num`; on operator/end, apply the **previous** op: `+`/`-` â†’ start new term; `*`/`/` â†’ merge with last term. Keep `total` and `last_term` to get **O(1) space**.
* **Why This Works?** `*`/`/` have higher precedence; by immediately folding them into the current term, additions/subtractions can be summed later without breaking order.
* **Edge Cases Considered:** spaces anywhere; multi-digit numbers; trailing number; negative intermediate results with division; large intermediates within 32-bit signed; left-to-right associativity for same-precedence ops.

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Stack / Expression Evaluation (Calculator pattern).
* **Common Problems Using This:** LC 224, 772 (with parentheses), 150 (RPN), 241 (divide & conquer expressions).

## ðŸ”¹ Tricks & Patterns Used

* **Operator-precedence via terms:** Defer `+`/`-`, eagerly fold `*`/`/`.
* **Truncate-toward-zero division:** `int(a/b)` (not `//`).
* **Boundary processing:** Treat end-of-string like an operator boundary.

## ðŸ”¹ Alternative Data Structures

* **Stack of terms** (numbers only) versus **O(1) last-term method**; no need for a full AST, deque, or tree.

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) â€” each char processed once.
* **Space Complexity:** O(1) with `last_term` trick; O(n) with stack (worst case many `+`/`-`).

## ðŸ”¹ Code Snippet (Optimized O(1) Space)

```python
class Solution:
    def calculate(self, s: str) -> int:
        """
        Time: O(n) â€” single pass
        Space: O(1) â€” uses running totals (no stack)
        """
        total = 0          # sum of committed terms
        last_term = 0      # current additive term to be committed later
        num = 0
        op = '+'

        for i, c in enumerate(s):
            if c.isdigit():
                num = num * 10 + (ord(c) - 48)

            # boundary: operator or end of string
            if c in '+-*/' or i == len(s) - 1:
                if op == '+':
                    total += last_term
                    last_term = num
                elif op == '-':
                    total += last_term
                    last_term = -num
                elif op == '*':
                    last_term = last_term * num
                else:  # '/'
                    # truncate toward zero
                    last_term = int(last_term / num)

                op = c
                num = 0

        return total + last_term
```

## ðŸ”¹ Common Misconceptions (cm)

* **"Use // for division"** â†’ Wrong for negatives; must **truncate toward zero**.
* **"Push operators to stack"** â†’ We push **signed numbers**; ops are applied at boundaries.
* **"Left-to-right only"** â†’ Precedence matters; `*`/`/` must fold before `+`/`-`.

---

### Mini Tests

* `"3+2*2" â†’ 7`
* `" 3/2 " â†’ 1`
* `" 3+5 / 2 " â†’ 5`
* `"8/2*3+1" â†’ 13` (left-to-right within same precedence)
* `"14-3/2" â†’ 13` (division before subtraction; truncate toward zero)
