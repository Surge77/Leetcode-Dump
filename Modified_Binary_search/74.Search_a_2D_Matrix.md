# ðŸ”¹ Problem Name: Search a 2D Matrix (Arrays/Binary Search, Medium)

**ðŸ”— Link:** [Leetcode 74](https://leetcode.com/problems/search-a-2d-matrix/)
**ðŸŸ¢ Status:** âœ… Solved (keep for revision: mark ðŸ”„ if you want to revisit)

---

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Two-phase binary search â€” first on rows, then within the chosen row.
* **Core Concept:** Binary Search adapted to a 2D matrix with disjoint, ordered row intervals.
* **When to Use This Pattern?** When each row is sorted, and **the first element of each row is greater than the last of the previous row**.
* **Mistakes to Avoid:**
  * Using staircase search (O(m+n)) when O(log m + log n) is possible.
  * Forgetting early exit when `top > bot`.
  * Not handling empty matrix edge case if constraints allow it.

---

## ðŸ”¹ Optimization Path

* **Brute Force:** O(mÂ·n) â€” scan all elements.
* **Optimized:** O(log m + log n) â€” binary search rows, then binary search columns.
* **Alternative:** Flattened binary search on mÂ·n elements â€” O(log(mÂ·n)) with index mapping.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:**
  1. Phase 1: Binary search rows using `[row_first, row_last]` intervals to find candidate row.
  2. Phase 2: Binary search inside that row.
* **Why This Works?** Row intervals are disjoint & ordered, so phase 1 narrows to exactly one candidate row.
* **Edge Cases:**
  * Target outside global min/max.
  * Single row / single column.
  * Empty matrix (optional check).

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Modified Binary Search (#5 in 15-patterns)
* **Related Problems:**
  * Rotated Sorted Array search (two-phase)
  * Search in 2D Matrix II (staircase search)
  * Search insert position in sorted array

---

## ðŸ”¹ Tricks & Patterns Used

* Monotone interval check for phase 1.
* Standard binary search for phase 2.
* Inclusive bound handling.

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(log m + log n)
* **Space Complexity:** O(1)

---

## ðŸ”¹ Code Snippet (Optimized)

```python
# Time Complexity: O(log m + log n)
# Space Complexity: O(1)
from typing import List

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        # Guard for empty input (safe even if constraints say non-empty)
        if not matrix or not matrix[0]:
            return False

        ROWS, COLS = len(matrix), len(matrix[0])

        # Phase 1: Binary search on rows to locate the only possible row
        top, bot = 0, ROWS - 1
        while top <= bot:
            row = (top + bot) // 2
            if target > matrix[row][COLS - 1]:
                top = row + 1
            elif target < matrix[row][0]:
                bot = row - 1
            else:
                break  # row interval contains target

        if top > bot:
            return False

        row = (top + bot) // 2

        # Phase 2: Standard binary search within the identified row
        l, r = 0, COLS - 1
        while l <= r:
            m = (l + r) // 2
            if matrix[row][m] == target:
                return True
            if matrix[row][m] < target:
                l = m + 1
            else:
                r = m - 1
        return False
```

---

## ðŸ”¹ Alternate Implementation â€” Flattened 1D Binary Search (Single Phase)

**When to use:** Same matrix property (disjoint row intervals). This version treats the matrix as a single sorted array to run one binary search.

```python
# Time Complexity: O(log (m*n))
# Space Complexity: O(1)
from typing import List

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix or not matrix[0]:
            return False
        m, n = len(matrix), len(matrix[0])
        lo, hi = 0, m * n - 1
        while lo <= hi:
            mid = (lo + hi) // 2
            r, c = divmod(mid, n)  # r = mid // n, c = mid % n
            val = matrix[r][c]
            if val == target:
                return True
            if val < target:
                lo = mid + 1
            else:
                hi = mid - 1
        return False
```

**Notes:** Comparable asymptotics to twoâ€‘phase; pick whichever you find clearer.

---

## ðŸ”¹ Decision Guide â€” Which Pattern When?


| Matrix property                                  | Best pattern                               | Time                         |
| ------------------------------------------------ | ------------------------------------------ | ---------------------------- |
| Rows sorted,**first of row i > last of row i-1** | Twoâ€‘phase binary search**or**Flattened 1D | O(log m + log n) / O(log mn) |
| Rows & cols sorted,**row ranges overlap**        | Staircase search                           | O(m + n)                     |
| No ordering guarantee                            | Linear scan / hashing                      | O(mn)                        |

---

## ðŸ”¹ Robustness & Edgeâ€‘Case Checklist

* âœ… Guard `if not matrix or not matrix[0]: return False`
* âœ… Handle tiny shapes (1Ã—1, 1Ã—n, mÃ—1)
* âœ… Early exit if `target < matrix[0][0]` or `target > matrix[-1][-1]` (implicit via Phase 1)
* âœ… Inclusive bounds; avoid infinite loops

---

## ðŸ”¹ Interview Soundâ€‘bites (for fast recall)

* "Rows form disjoint, ordered intervals â†’ binary search the interval, then the row."
* "Twoâ€‘phase vs flattened is a readability choice; both are logarithmic."
* "Use staircase only when rows/cols are both sorted but intervals overlap."
