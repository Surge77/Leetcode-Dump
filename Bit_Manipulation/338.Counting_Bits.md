# 🔹 Problem Name: Counting Bits (Dynamic Programming + Bit Manipulation, Easy)

**🔗 Link:** [LeetCode 338 - Counting Bits](https://leetcode.com/problems/counting-bits/)
**🟢 Status:** ✅ Solved

---

## 🔹 Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** **Dynamic Programming (DP)** with bitwise recurrence.
* **Core Concept:** Use the relation `dp[i] = dp[i >> 1] + (i & 1)`.
* **When to Use This Pattern?** When you need bit counts for all numbers up to `n`.
* **Mistakes to Avoid:**

  * Overcomplicating by scanning every bit of every number.
  * Forgetting that `i >> 1` effectively drops the least significant bit.
  * Misunderstanding `(i & 1)` as something other than “is the last bit set?”

---

## 🔹 Optimization Path

* **Naive:** For each number, count bits with shifting/AND. O(n * 32).
* **Better:** Use Brian Kernighan’s per-number bit count. O(n * k), where k = set bits.
* **Optimized Solution (This):** DP recurrence using `i >> 1`. O(n).
* **Further Improvements Possible?** Not much; this is optimal in both time and clarity.

---

## 🔹 Solution Breakdown

* **Optimal Approach:** `dp[i] = dp[i >> 1] + (i & 1)`.
* **Why This Works?**

  * `i >> 1` removes the last bit → reuses precomputed bit count.
  * `(i & 1)` checks if the last bit is 1 → add 1 if set.
* **Edge Cases Considered:**

  * n = 0 → returns [0].
  * Works for all positive integers up to constraints (10^5 or higher).

---

## 🔹 Pattern Recognition

* **Belongs To:** Dynamic Programming + Bit Manipulation.
* **Common Problems Using This:**

  * [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
  * [231. Power of Two](https://leetcode.com/problems/power-of-two/)
  * [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)
  * [401. Binary Watch](https://leetcode.com/problems/binary-watch/)

---

## 🔹 Tricks & Patterns Used

* **Right shift (`>>`)** to reuse smaller subproblems.
* **Bitwise AND (`& 1`)** to detect last bit.
* **DP recurrence** to avoid redundant calculations.

---

## 🔹 Alternative Data Structures

Not applicable — DP array + integers suffice.

---

## 🔹 Complexity Analysis

* **Time Complexity:** O(n) → single pass.
* **Space Complexity:** O(n) → DP array.

---

## 🔹 Code Snippet (Optimized)

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(n + 1):
            dp[i] = dp[i >> 1] + (i & 1)
        return dp

# ⏱ Time: O(n)
# 💾 Space: O(n)
```

---

✅ **Final Takeaway:** Counting Bits shines as a **DP + bitwise hybrid**: reuse half-sized subproblems with a single recurrence, yielding a clean O(n) solution that’s both elegant and efficient.
