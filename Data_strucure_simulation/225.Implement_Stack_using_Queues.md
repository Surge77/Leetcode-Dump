# 🔹 Problem Name: 225. Implement Stack using Queues (Design / DS Adapter, Medium)

**🔗 Link:** [225. Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)
**🟢 Status:** ✅ Solved

---

## 🔹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Emulate **LIFO** behavior using **FIFO** queues via **rotation** or **drain-and-swap**.
* **Core Concept:** **Data-Structure Adapter (Semantics Emulation)** — adapt operations of one DS to behave like another.
* **When to Use This Pattern?** When you see “**implement X using Y**” and must **preserve operation semantics** with complexity trade-offs.
* **Mistakes to Avoid:**

  * Rotating the queue **exactly `size-1`** times after each push in the single-queue method.
  * Mixing up **front vs back** when mapping `top()`/`pop()`.
  * Incorrectly assuming **amortized** O(1) where the method is truly O(n) worst-case.
  * Forgetting to handle or at least document behavior for **empty stack** calls (LeetCode won’t call invalid ops, but your API might).

---

## 🔹 Optimization Path

* **Brute Force (conceptual):** Two-queue **pop-heavy** variant — move `n-1` items to an auxiliary queue on each `pop/top`, then swap queues.
  **Complexity:** `push: O(1)`, `pop/top: O(n)`, `space: O(n)`.
* **Optimized Solution (chosen):** **Single-queue rotate (push-heavy)** — enqueue new element, then rotate previous elements to move the new item to the front.
  **Complexity:** `push: O(n)`, `pop/top: O(1)`, `space: O(n)`.
* **Further Improvements Possible?**

  * If your workload is `push`-heavy and `pop/top`-rare, prefer **two-queue pop-heavy**.
  * If `pop/top` dominate, prefer **single-queue rotate** (this template).
  * API hardening: raise custom exceptions for empty ops if required.

---

## 🔹 Solution Breakdown

* **Optimal Approach:** Maintain a **single queue**. On `push(x)`, `append(x)` then **rotate** the queue `size-1` times so that `x` becomes the **front**. This makes `pop()` a simple `popleft()` and `top()` a peek at index 0.
* **Why This Works?** By rotating after each push, we **reorder** the queue so that the **last pushed** element sits at the **front**, perfectly matching **LIFO** semantics without extra structures.
* **Edge Cases Considered:**

  * Multiple `top()` calls without `pop()`.
  * Continuous `pop()` until empty.
  * Large sequences to ensure no hidden state bugs.

---

## 🔹 Pattern Recognition

* **Belongs To:** **Data-Structure Adapter (Semantics Emulation)** → **Queue Rotation** (push-heavy) / **Two-Queue Drain** (pop-heavy).
* **Common Problems Using This:**

  * 232. Implement Queue using Stacks (two-stack adapter)
  * Design Deque via Two Stacks (adapter)
  * MinQueue via Two Stacks (monotonic + adapter)

---

## 🔹 Tricks & Patterns Used

* **Semantics Emulation:** Mapping LIFO on top of FIFO.
* **Rotation Invariant:** After `push`, the **front** is always the latest element.
* **Complexity Trade-off Tuning:** Choose push-heavy vs pop-heavy based on expected operation mix.

---

## 🔹 Alternative Data Structures

* If constraints allowed, a **deque** directly provides `append`/`pop` (stack), but the task **requires queues**.
* Two-queue variant for different complexity profile.

---

## 🔹 Complexity Analysis

* **Time Complexity (single-queue rotate):**

  * `push`: **O(n)** — rotate `size-1` elements
  * `pop`: **O(1)** — `popleft()`
  * `top`: **O(1)** — peek front
* **Space Complexity:** **O(n)** for stored elements.

---

## 🔹 Code Snippet (Optimized)

```python
from collections import deque

class MyStack:
    """
    Stack implemented using a single queue (push-heavy / rotate-on-push).

    Complexity:
      - push: O(n)  (rotate size-1 elements)
      - pop:  O(1)
      - top:  O(1)
      - space: O(n)
    """
    def __init__(self):
        self.q = deque()

    def push(self, x: int) -> None:
        # 1) Enqueue new element
        self.q.append(x)
        # 2) Rotate previous elements to bring x to the front (stack top)
        for _ in range(len(self.q) - 1):
            self.q.append(self.q.popleft())

    def pop(self) -> int:
        # Front is the current top due to rotation invariant
        return self.q.popleft()

    def top(self) -> int:
        return self.q[0]

    def empty(self) -> bool:
        return len(self.q) == 0
```

---

### 🔹 Variant (For Reference): Two-Queue Pop-Heavy

```python
from collections import deque

class MyStack:
    """
    Two queues, pop/top-heavy: push O(1), pop/top O(n), space O(n)
    """
    def __init__(self):
        self.a = deque()  # active
        self.b = deque()  # buffer

    def push(self, x: int) -> None:
        self.a.append(x)

    def pop(self) -> int:
        while len(self.a) > 1:
            self.b.append(self.a.popleft())
        val = self.a.popleft()
        self.a, self.b = self.b, self.a
        return val

    def top(self) -> int:
        while len(self.a) > 1:
            self.b.append(self.a.popleft())
        val = self.a[0]
        self.b.append(self.a.popleft())
        self.a, self.b = self.b, self.a
        return val

    def empty(self) -> bool:
        return not self.a
```

---

## 🔹 CM (Common Misconceptions)

* **“Rotate on pop, not push, and still keep pop O(1).”** No — if you defer rotation to `pop`, that `pop` becomes **O(n)**.
* **“Top is the back of the queue.”** Not in the push-rotate variant; **top is the front**.
* **“Amortized O(1) magically applies.”** Not here; costs are deterministic per op per chosen variant.
* **“Two-queue is always slower.”** Depends on workload; it makes `push` O(1), which can be superior if pushes dominate.

---

## 🔹 Notes on Your Draft Code

* Calling `self.push(self.popleft())` in `pop()` is incorrect (recursion + missing `self.q.` + wrong rotation phase).
* In single-queue rotate, **rotate during `push`**, not during `pop`.
* Use `self.q.popleft()` and keep the invariant: **front == stack top**.
