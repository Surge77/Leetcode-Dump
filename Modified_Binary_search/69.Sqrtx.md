# ğŸ”¹ Problem Name: Sqrt(x) (Math/Binary Search, Easy)

**ğŸ”— Link:** [LeetCode 69 â€” Sqrt(x)](https://leetcode.com/problems/sqrtx/)
**ğŸŸ¢ Status:** âœ… Solved

---

## ğŸ”¹Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Binary Search over the integer range $0, x$ to find the largest `m` with `m*m â‰¤ x`.
* **Core Concept:** Monotonic predicate on `m`: `m*m â‰¤ x` flips from trueâ†’false exactly once â‡’ perfect for binary search.
* **When to Use This Pattern?**
  Use binary search when you can phrase the problem as: *find the boundary (max/min) index/value that satisfies a monotone condition*. Here: "is `m*m â‰¤ x`?"
* **Mistakes to Avoid:**

    1. Off-by-one on bounds (`left â‰¤ right` vs `left < right`).
    2. Not storing the best candidate (floor) when `m*m < x`.
    3. Overflow in other languages when computing `m*m` (use `long`/`64-bit` or compare as `m â‰¤ x/m`).

---

## ğŸ”¹ Optimization Path

* **Brute Force:** Test `i*i` from 1 upward until `i*i > x`.
  **Time:** O($\sqrt{x}$)
  **Space:** O(1)
* **Optimized Solution (Binary Search):** Search `m` in $0, x$. Track best answer when `m*m < x`.
  **Time:** O(log x)
  **Space:** O(1)
* **Further Improvements Possible?**
  **Newtonâ€™s Method** (a.k.a. Babylonian method): converge to $\sqrt{x}$ with quadratic convergence.
  **Time:** Typically O(log log x) iterations, fast in practice.
  **Space:** O(1).
  Ref: [Newton's Method (Wikipedia)](https://en.wikipedia.org/wiki/Newton%27s_method)

---

## ğŸ”¹ Solution Breakdown

* **Optimal Approach:** Binary search on integers; maintain `result` as the floor candidate when `mid*mid < x`.
* **Why This Works?** `mid*mid` increases with `mid` (monotone). If `mid*mid > x`, true root is smaller â†’ move `right`. If `< x`, itâ€™s a valid floor candidate â†’ move `left` up and store `mid`.
* **Edge Cases Considered:** `x=0`, `x=1`, perfect squares (e.g., 4, 9), large `x` (avoid overflow in non-Python langs), minimal bounds (`left=0`, `right=x`).

---

## ğŸ”¹ Pattern Recognition

* **Belongs To:** Modified Binary Search (a.k.a. boundary finding).
* **Common Problems Using This:**

    * [367. Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/) â€” check if `n` is a perfect square via binary search.
    * [278. First Bad Version](https://leetcode.com/problems/first-bad-version/) â€” boundary search (first true).
    * [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/) â€” lower bound variant.
    * [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) â€” binary search on answer (speed).

---

## ğŸ”¹ Tricks & Patterns Used

* **Binary Search Boundary Pattern:** Maintain invariant that `result` is last seen valid candidate.
* **Overflow Guard (Non-Python):** Compare as `mid <= x / mid` or cast to 64-bit before squaring.
* **Mid Calculation:** `mid = left + (right-left)//2` â€” avoids overflow in fixed-width integer languages.

---

## ğŸ”¹ Alternative Data Structures

* Not needed. Problem is numeric & monotone; DS wonâ€™t beat binary search here.
* Math alternative: Newtonâ€™s method (iterative numeric technique) instead of DS.

---

## ğŸ”¹ Complexity Analysis

* **Time Complexity:** O(log x) â€” halves the search space each iteration.
* **Space Complexity:** O(1) â€” constant auxiliary storage.

---

## ğŸ”¹ Code Snippet (Optimized â€” Binary Search)

```python
# Time: O(log x)
# Space: O(1)
class Solution:
    def mySqrt(self, x: int) -> int:
        left, right = 0, x
        result = 0
        while left <= right:
            mid = left + (right - left) // 2
            sq = mid * mid
            if sq > x:
                right = mid - 1
            elif sq < x:
                result = mid  # best floor candidate so far
                left = mid + 1
            else:
                return mid  # perfect square
        return result  # floor when no exact square
```

<details>
<summary>Alternate: Newtonâ€™s Method (fast in practice)</summary>

```python
# Time: ~O(log log x) iterations; Space: O(1)
class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:
            return x
        r = x  # initial guess
        while r * r > x:
            r = (r + x // r) // 2  # integer Newton step
        return r
```

**Note:** The integer variant uses `//` to keep guesses integral and naturally converges to the floor.

</details>

---

## ğŸ”¹ Common Misconceptions (cm)

* **â€œMust try numbers from 0 to x.â€** Linear scan is unnecessary; monotonicity enables O(log x).
* **â€œOrder of checks doesnâ€™t matter.â€** You must store the candidate when `mid*mid < x`, else youâ€™ll lose the floor.
* **â€œOverflow isnâ€™t a concern.â€** In C++/Java, `mid*mid` can overflow `int`; use `long` or compare as `mid <= x/mid`.
* **â€œLeft/right boundaries donâ€™t matter.â€** Wrong bounds or loop condition causes off-by-one bugs.

---

## ğŸ”¹ 80/20 (8ty)

* The 20% that gives 80% wins:

    1. Frame as boundary search on a monotone predicate.
    2. Maintain `result` for floor.
    3. Use safe mid & overflow-aware comparisons.

---

## ğŸ”¹ Related Reading

* [Binary Search â€” LeetCode Explore Card](https://leetcode.com/explore/learn/card/binary-search/)
* [Newtonâ€™s Method â€” Wikipedia](https://en.wikipedia.org/wiki/Newton%27s_method)

---

## ğŸ”¹ Test Trace Example (x = 10)

* `left=0, right=10 â†’ mid=5 â†’ 25>10 â†’ right=4`
* `left=0, right=4 â†’ mid=2 â†’ 4<10 â†’ result=2, left=3`
* `left=3, right=4 â†’ mid=3 â†’ 9<10 â†’ result=3, left=4`
* `left=4, right=4 â†’ mid=4 â†’ 16>10 â†’ right=3`
* Loop ends (`left>right`), return **3**.

---

## ğŸ”¹ Interview Power Move

> â€œModel `m*m â‰¤ x` as a monotone predicate and binary-search the boundary. Store `mid` when valid to get the floor; use safe mid and overflow checks.â€
