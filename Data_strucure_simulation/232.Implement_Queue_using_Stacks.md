# ðŸ”¹ Problem Name: Implement Queue using Stacks (Stack/Queue, Easy)

**ðŸ”— Link:** [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)
**ðŸŸ¢ Status:** ðŸ”„ Need Review

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Two stacks with **lazy transfer** (move `input â†’ output` only when `output` is empty)
* **Core Concept:** Stackâ†”Queue **simulation** + **amortized analysis**
* **When to Use This Pattern?** When you must provide FIFO behavior but are restricted to stack ops (`push`, `pop`, `top`).
* **Mistakes to Avoid:**

  * Moving elements on **every** operation (kills amortized O(1)).
  * Using `list.pop(0)` (O(n)).
  * Forgetting to route `pop()` through `peek()` (duplicate transfer logic).
  * Handling empty-queue cases poorly (underflow); rely on problem constraints or guard.

---

## ðŸ”¹ Optimization Path

* **Brute Force:** Maintain queue order after each `push` by shuttling all items between stacks â†’ **O(n)** per `push`/`pop`.
* **Optimized Solution:** **Lazy transfer**; each element moves **at most once** from `input` to `output` â†’ **amortized O(1)** ops.
* **Further Improvements Possible?** If stacks arenâ€™t mandated, use `collections.deque` for worst-case **O(1)** queue ops; otherwise this is optimal under the constraint.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Keep two stacks: `input` (collects pushes) and `output` (serves front). On `peek`/`pop`, if `output` is empty, pour all items from `input` into `output` to restore FIFO order.
* **Why This Works?** Two reversals restore original order; since each item is moved at most once, total work over `m` ops is O(m) â†’ **amortized O(1)** per op.
* **Edge Cases Considered:** empty queue calls (per constraints), single element, alternating `push`/`pop`, batch pushes followed by batch pops.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** **Data Structure Transformation** (Two Stacks â†’ Queue), **Stack/Queue** toolkit.
* **Common Problems Using This:**

  * LC 225 **Implement Stack using Queues** (dual idea).
  * Design **MinQueue** using two stacks with mins (variant).
  * Stream processing with amortized data moves (editor undo/redo, browser history models).

---

## ðŸ”¹ Tricks & Patterns Used

* **Two reversals = original order**
* **Lazy Transfer** (defer expensive work until needed)
* **Amortized Analysis** (each element moved once)
* **Idempotent `peek()`** centralizes the transfer logic.

---

## ðŸ”¹ Alternative Data Structures

* **Deque** (if allowed): native FIFO with O(1) ends.
* **Linked-list queue** with head/tail pointers (true FIFO, explicit nodes).

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** `push` O(1); `pop` O(1) **amortized**; `peek` O(1) **amortized**; `empty` O(1).
* **Space Complexity:** O(n) for `n` elements across both stacks.

---

## ðŸ”¹ Code Snippet (Optimized)

```python
class MyQueue:
    """
    Queue via two stacks with lazy transfer.

    Complexity (per operation):
    - push: O(1)
    - pop:  amortized O(1)
    - peek: amortized O(1)
    - empty: O(1)
    Space: O(n) across both stacks for n elements.
    """

    def __init__(self):
        self.input = []   # collects new elements (LIFO)
        self.output = []  # serves elements in FIFO order

    def push(self, x: int) -> None:
        """O(1) â€” just append to input stack."""
        self.input.append(x)

    def _replenish_output(self) -> None:
        """Pour inputâ†’output if output is empty (lazy transfer)."""
        if not self.output:  # only when needed
            while self.input:
                self.output.append(self.input.pop())

    def peek(self) -> int:
        """Amortized O(1) â€” ensure output has current front, then return it."""
        self._replenish_output()
        return self.output[-1]

    def pop(self) -> int:
        """Amortized O(1) â€” reuse peek path to centralize transfer logic."""
        self._replenish_output()
        return self.output.pop()

    def empty(self) -> bool:
        """O(1) â€” true when both stacks are empty."""
        return not self.input and not self.output

# Example usage
# q = MyQueue()
# q.push(1); q.push(2)
# assert q.peek() == 1
# assert q.pop() == 1
# assert q.empty() is False
```
