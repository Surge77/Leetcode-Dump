## ðŸš€ **1. First Principles Thinking (FPT)**

ðŸ’¡ **What it is:** Breaking down the problem into fundamental truths and reasoning up from there.
ðŸŽ¯ **Use it for:** Deep insights, root cause analysis, and conceptual clarity.

ðŸ“Œ **How to prompt:**

> "Explain this code using **First Principles Thinking (FPT)**â€”break it down to its most fundamental concepts, avoid analogies, and reconstruct it logically."

âœ… **Example:**
ðŸ”¹ Given an algorithm, break it down into **core operations (loops, conditions, data structures)** and analyze its behavior at the most atomic level.

---

## ðŸ— **2. Step-by-Step Execution (Dry Run)**

ðŸ’¡ **What it is:** Simulating how the code executes **line by line** with sample input.
ðŸŽ¯ **Use it for:** Debugging, visualization, and understanding loops/conditions.

ðŸ“Œ **How to prompt:**

> "Walk through this code **step by step** with an example input and show how the variables change at each step."

âœ… **Example:**
ðŸ”¹ Given an array-processing algorithm, show how **each iteration updates variables** in a table format.

---

## ðŸŽ­ **3. Pattern Recognition & Analogies**

ðŸ’¡ **What it is:** Relating the code to **common problem-solving patterns** or real-world analogies.
ðŸŽ¯ **Use it for:** Recognizing repeated problem structures, high-level intuition.

ðŸ“Œ **How to prompt:**

> "Compare this code to a **real-world analogy** and explain how it follows common patterns like DP, Sliding Window, etc."

âœ… **Example:**
ðŸ”¹ Explaining **binary search** using a **dictionary lookup analogy** or explaining **recursion** using **Russian dolls.**

---

## ðŸ” **4. Time Complexity & Optimization Path**

ðŸ’¡ **What it is:** Understanding **how the code scales** and if thereâ€™s a **better approach.**
ðŸŽ¯ **Use it for:** Performance tuning, algorithmic efficiency.

ðŸ“Œ **How to prompt:**

> "Break down the **time and space complexity** of this code, identify the bottlenecks, and suggest optimizations."

âœ… **Example:**
ðŸ”¹ Given an **O(nÂ²) brute-force** algorithm, check if **sorting or data structures** can reduce it to **O(n log n) or O(n).**

---

## ðŸ›  **5. Code Deconstruction (Explain Like Iâ€™m 5 - ELI5)**

ðŸ’¡ **What it is:****Breaking down complex code into simple, beginner-friendly chunks.**
ðŸŽ¯ **Use it for:****Grasping new topics, intuitive learning, and quick understanding.**

ðŸ“Œ **How to prompt:**

> "Explain this code like Iâ€™m 5 (ELI5) using **simple terms, metaphors, and clear logic.**"

âœ… **Example:**
ðŸ”¹ Explaining recursion as **a chef following a recipe and calling another chef when stuck.**

---

## ðŸŽ **6. Edge Cases & Failure Scenarios**

ðŸ’¡ **What it is:** Stress-testing the code with **edge cases** to understand where it breaks.
ðŸŽ¯ **Use it for:** Finding weaknesses, debugging.

ðŸ“Œ **How to prompt:**

> "What are the edge cases for this code? How does it behave in worst-case scenarios?"

âœ… **Example:**
ðŸ”¹ Checking if an **array-sorting algorithm** handles **duplicates, empty inputs, or large numbers.**

---

## ðŸ§© **7. Comparative Analysis (Alternative Approaches)**

ðŸ’¡ **What it is:** Comparing multiple ways to solve the same problem and choosing the best.
ðŸŽ¯ **Use it for:** Evaluating different approaches.

ðŸ“Œ **How to prompt:**

> "Explain this approach vs. [brute force / DP / greedy / two pointers] and compare their strengths/weaknesses."

âœ… **Example:**
ðŸ”¹ Comparing **brute force vs. DP for Fibonacci**, showing how **memoization reduces redundant computations.**

---

## ðŸ”¥ **How to Use These for Elite-Level Explanations?**

Whenever you request an explanation, **combine multiple frameworks** for **maximum clarity.**

ðŸ“Œ **Example Prompt for an Elite Explanation:**

> "Explain this code using:
>
> * **FPT** to break it into fundamentals,
> * **Step-by-step execution** with an example,
> * **Pattern recognition** to relate it to common problems,
> * **Complexity analysis** to check performance,
> * **Alternative approaches** for comparison."
>
