# 🔹 Problem Name: Number of 1 Bits / Hamming Weight (Bit Manipulation, Easy)

**🔗 Link:** [LeetCode 191 - Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
**🟢 Status:** ✅ Solved

---

## 🔹 Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Use **Brian Kernighan’s Algorithm** to count set bits.
* **Core Concept:** **Bit Manipulation** (clear lowest set bit trick).
* **When to Use This Pattern?** Whenever asked to count the number of 1s (set bits) in binary representation efficiently.
* **Mistakes to Avoid:**

  * Thinking you must scan all 32 bits (wasteful when n is sparse).
  * Forgetting that `n & (n-1)` actually removes exactly one set bit.
  * Misunderstanding negative numbers in Python (masking may be needed for 32-bit simulation).

---

## 🔹 Optimization Path

* **Naive:** Check every bit with mask `(1 << i)` in a loop. O(32).
* **Better:** Right shift and check LSB until n becomes zero. O(log n).
* **Optimized Solution (This):** Brian Kernighan’s algorithm. O(k), where k = number of set bits.
* **Further Improvements Possible?** Modern CPUs offer `popcount` instruction for O(1) hardware-level count.

---

## 🔹 Solution Breakdown

* **Optimal Approach:** Repeatedly clear the lowest set bit (`n &= n - 1`) and increment a counter until `n` becomes zero.
* **Why This Works?** Subtracting 1 flips the lowest set bit and all bits to the right. ANDing removes exactly that lowest set bit from `n`.
* **Edge Cases Considered:**

  * Zero → returns 0 immediately.
  * Large 32-bit integers.
  * Sparse vs dense bit patterns.

---

## 🔹 Pattern Recognition

* **Belongs To:** Bit Manipulation (Set Bit Tricks).
* **Common Problems Using This:**

  * [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
  * [231. Power of Two](https://leetcode.com/problems/power-of-two/) (relies on `n & (n-1) == 0`)
  * [268. Missing Number](https://leetcode.com/problems/missing-number/) (XOR trick).
  * [338. Counting Bits](https://leetcode.com/problems/counting-bits/).

---

## 🔹 Tricks & Patterns Used

* **`n & (n-1)`** → clears the lowest set bit.
* Loop count = number of set bits.
* Efficient for sparse numbers with few set bits.

---

## 🔹 Alternative Data Structures

Not applicable — this is a pure bitwise operation technique.

---

## 🔹 Complexity Analysis

* **Time Complexity:** O(k), where k = number of set bits.
* **Space Complexity:** O(1).

---

## 🔹 Code Snippet (Optimized)

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        res = 0
        while n:
            n &= n - 1  # clear the lowest set bit
            res += 1
        return res

# ⏱ Time: O(k), k = number of set bits
# 💾 Space: O(1)
```

---

✅ **Final Takeaway:** Brian Kernighan’s algorithm is the most elegant way to count set bits — efficient, minimal, and interview-friendly. Perfect example of **bitwise brilliance** in action.
