# ðŸ”¹ **Problem Overview**

**Title:** [Binary Tree Right Side View (LeetCode 199)](https://leetcode.com/problems/binary-tree-right-side-view/)

**Difficulty:** ðŸŸ¡ Medium

**Date Solved:** 2025-10-22

**Status:** âœ… Solved

---

## ðŸ”¹ **Step 1 â€” Problem Understanding**

**In My Own Words:**

Given a binary tree, return the values of the nodes you can see when viewing it from the right side â€” i.e., the last node at each level.

**Input â†’ Output Mapping:**

Binary Tree â†’ List[int] (each element = rightmost node at each level).

**Constraints:**

* Node count n âˆˆ [0, 10^4]
* Node values: integers (can be negative or positive)
* Tree may be skewed or balanced
* Time: O(n) expected; must handle empty tree safely

**Edge Cases Identified:**

* Empty tree â†’ []
* Single node â†’ [root.val]
* Left-skewed tree â†’ top to bottom values
* Right-skewed tree â†’ identical to root-to-leaf path
* Null children in mixed subtrees

---

## ðŸ”¹ **Step 2 â€” Core Thinking Process**

**1. Pattern Recognition:**

* **15patterns:** Tree Traversal â†’ Level-order BFS pattern
* Goal is to isolate each level and capture the rightmost element.

**2. Brute Force Idea:**

* Traverse all nodes and store per-level arrays, then take last element from each level list.

**3. Optimization Trigger:**

* Observation: You donâ€™t need to store entire levels. Track the *last* node processed per level using queue length.

**4. Chosen Approach:**

* **BFS Level-order Traversal:** Process nodes level by level using a queue, capturing the last node in each level.

**5. Algorithm Steps (Pseudo-Logic):**

```
Initialize res = []
Initialize queue = [root]
While queue not empty:
    levelSize = len(queue)
    rightmost = None
    for each node in current level:
        node = queue.popLeft()
        if node exists:
            rightmost = node
            queue.append(node.left)
            queue.append(node.right)
    if rightmost exists:
        res.append(rightmost.val)
Return res
```

---

## ðŸ”¹ **Step 3 â€” Implementation**

**Optimized Code:**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from collections import deque
from typing import Optional, List

class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []
        q = deque([root])

        while q:
            rightSide = None
            qLen = len(q)

            for i in range(qLen):
                node = q.popleft()
                if node:
                    rightSide = node
                    q.append(node.left)
                    q.append(node.right)

            if rightSide:
                res.append(rightSide.val)
        return res
```

**Time Complexity:** O(n) â€” each node is processed once.

**Space Complexity:** O(w) â€” proportional to the maximum width of the tree.

**Edge Cases Handled:** âœ… Empty, skewed, null children, unbalanced trees.

---

## ðŸ”¹ **Step 4 â€” Reflection**

**Why This Works:**

BFS naturally explores level by level, so the last node processed in each level is the rightmost visible one.

**Common Misconceptions (cm):**

* [X]  Need to traverse right children first â†’ unnecessary; BFS order suffices.
* [X]  Must store full levels â†’ only last node matters.
* [X]  Null handling ignored â†’ must check before enqueuing.

**Optimization Opportunities:**

* **DFS alternative:** Right-first traversal with depth tracking (same O(n), less intuitive for wide trees).
* **Space tuning:** Skip appending nulls to queue to reduce space.

---

## ðŸ”¹ **Step 5 â€” Pattern Journal**

**Belongs To Pattern:** Level-order BFS Traversal

**Trigger Words to Recognize Next Time:** â€œright side viewâ€, â€œvisible from rightâ€, â€œlevel orderâ€, â€œrightmost per levelâ€

**Related Problems:**

* Binary Tree Level Order Traversal (LeetCode 102)
* Left Side View of Binary Tree (variation)
* Binary Tree Zigzag Level Order Traversal (LeetCode 103)

**Generalized Formula / Idea:**

* Any *side view* can be solved using level-order traversal by capturing either the first (left view) or last (right view) node at each level.

---

## ðŸ”¹ **Step 6 â€” Learning Notes**

**What I Learned (in one line):**

> Level-wise BFS with queue length = cleanest way to isolate visible nodes per level.

**What Tripped Me Up:**

> Initially thought right child must be processed first â€” not true for BFS.

**How Iâ€™ll Recognize This Pattern Faster Next Time:**

> Any mention of â€œper levelâ€ or â€œviewâ€ instantly signals BFS pattern.

---

## ðŸ”¹ **Step 7 â€” Meta Tags**

**Topic Tags:** Tree / BFS / Queue / Level Traversal

**Pattern Type:** BFS (15patterns #10 â€” Tree Traversal)

**Data Structures Used:** Deque (queue), Binary Tree

**Review Frequency:** ðŸ” Weekly

**Confidence Level:** ðŸ’ª High

---

## ðŸ”¹ **Step 8 â€” Snapshot Summary**

**Problem in One Line:**

> Find the rightmost node at each depth using BFS.

**Solution in One Line:**

> BFS traversal; capture the last node per level.

**Pattern Keyword (for search):**

> Tree_RightSideView_BFS

---

## ðŸ”¹ **Step 9 â€” Version History**


| Version | Change                                     | Date       | Status |
| ------- | ------------------------------------------ | ---------- | ------ |
| v1.0    | Initial BFS-based solution                 | 2025-10-22 | âœ…     |
| v1.1    | Added DFS comparison and optimization note | 2025-10-22 | ðŸ”„     |

---

## ðŸ”¹ **Step 10 â€” Final Reflection Prompt**

> ðŸ§© Between BFS and DFS for side view, which scales better for wide vs. deep trees, and how does this influence recursion safety and memory tradeoffs?
