# 🔹 Problem Name: 73. Set Matrix Zeroes (Array/Matrix, Medium)

**🔗 Link:** [73. Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)
**🟢 Status:** ✅ Solved

---

## 🔹 Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Detect zeros first, then zero out corresponding rows/columns without letting newly written zeros cascade.
* **Core Concept:** Row/Column **marking** — either with auxiliary arrays (O(m+n) space) or by **hijacking the first row/column** as markers (O(1) space).
* **When to Use This Pattern?** When a matrix’s row/column needs a bulk transformation based on cell predicates but in-place constraints forbid naive multi-pass mutation.
* **Mistakes to Avoid (cm):**
  * Mutating while scanning → causes zero “infection.”
  * Forgetting to handle first row/column separately in O(1) approach.
  * Misusing `matrix[0][0]` (dual-purpose marker) without a separate flag.

---

## 🔹 Optimization Path

* **Brute Force:** For each zero, traverse entire row and column immediately → O(k·(m+n)) and risk cascading if done in-place incorrectly.
* **Optimized Solution A (Marker Arrays):** Use `rows[m]`, `cols[n]` boolean arrays. Time O(mn), Space O(m+n).
* **Optimized Solution B (Edge Hijacking):** Use first row/col as markers. Time O(mn), **Space O(1)**.

---

## 🔹 Solution Breakdown

### Optimal Approach (Space-Optimal, O(1) Space)

* **Idea:** First pass: mark columns in `matrix[0][c]` and rows in `matrix[r][0]`. Keep a `rowZero` flag for whether the **first row** originally had a zero. Second pass: zero inner cells based on markers. Finally, zero first column if `matrix[0][0]==0` and first row if `rowZero`.
* **Why This Works?** It separates **detection** (markers) from **transformation**, while storing metadata **in the matrix itself**. Flags prevent clobbering marker state for row 0/col 0.
* **Edge Cases Considered:** 1×1 matrix, zeros in first row, zeros in first column, all-zero matrix, no-zero matrix.

---

## 🔹 Pattern Recognition

* **Belongs To:** Array/Matrix — **In-place Marking** (a common trick family with constant-space metadata).
* **Common Problems Using This:**
  * Game of Life (in-place state encoding)
  * Image/Matrix rotations with minimal extra space
  * Spreadsheet-like propagation constraints

---

## 🔹 Tricks & Patterns Used

* **Bit/Flag Markers:** Use boundary row/col as metadata.
* **Two-Phase Transform:** (1) Mark, (2) Apply.
* **Sentinel Flags:** Handle `matrix[0][0]` ambiguity with a separate boolean (`rowZero`).

---

## 🔹 Alternative Data Structures

* **With Extra Space:** Boolean arrays `rows[m]`, `cols[n]` give simpler logic at cost of O(m+n) space.
* **Why Not Hash Sets?** Equivalent to boolean arrays functionally; arrays are simpler/faster and space-predictable.

---

## 🔹 Complexity Analysis

* **Time Complexity:** O(m·n) — each cell is visited a constant number of times.
* **Space Complexity:**
  * **O(1)** for the edge-hijacking approach (only a couple of booleans).
  * **O(m+n)** for the marker-arrays approach.

---

## 🔹 Code Snippet (Optimized — O(1) Space)

```python
# Time: O(m*n)
# Space: O(1)
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        ROWS, COLS = len(matrix), len(matrix[0])
        rowZero = False  # Did the first row originally contain a zero?

        # Phase 1: Mark columns using first row; mark rows using first column
        for r in range(ROWS):
            for c in range(COLS):
                if matrix[r][c] == 0:
                    matrix[0][c] = 0
                    if r > 0:
                        matrix[r][0] = 0
                    else:
                        rowZero = True

        # Phase 2: Apply zeros to inner matrix using markers
        for r in range(1, ROWS):
            for c in range(1, COLS):
                if matrix[0][c] == 0 or matrix[r][0] == 0:
                    matrix[r][c] = 0

        # Phase 3: First column
        if matrix[0][0] == 0:
            for r in range(ROWS):
                matrix[r][0] = 0

        # Phase 4: First row
        if rowZero:
            for c in range(COLS):
                matrix[0][c] = 0
```

---

## 🔹 Code Snippet (Marker Arrays — O(m+n) Space)

```python
# Time: O(m*n)
# Space: O(m+n)
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        ROWS, COLS = len(matrix), len(matrix[0])
        rows = [False] * ROWS
        cols = [False] * COLS

        # Pass 1: record which rows/cols need zeroing
        for r in range(ROWS):
            for c in range(COLS):
                if matrix[r][c] == 0:
                    rows[r] = True
                    cols[c] = True

        # Pass 2: apply zeroing
        for r in range(ROWS):
            for c in range(COLS):
                if rows[r] or cols[c]:
                    matrix[r][c] = 0
```

---

## 🔹 Common Misconceptions (cm)

* **“I can zero on the fly during scan.”** → New zeros will falsely trigger more rows/cols. Always separate mark vs. apply.
* **“`matrix[0][0]` only marks the first row.”** → It collides with first column too; use a separate `rowZero` flag.
* **“O(1) space is always faster.”** → Logic is trickier; on interviews it’s favored, but in practice, O(m+n) with clarity may be fine.

---

## 🔹 Edge Cases Handled

* Single cell matrices (1×1)
* All-zero or zero-free matrices
* Zeros in the first row or first column
* Very wide/tall matrices (stress markers and iteration order)

---

## 🔹 Interview Tips

* State the **two-phase** plan up front.
* Call out the **`matrix[0][0]` ambiguity** and the `rowZero` flag explicitly.
* Implement the O(m+n) version first, then upgrade to O(1) if time allows.
