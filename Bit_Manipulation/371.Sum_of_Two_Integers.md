# 🔹 Problem Name: Sum of Two Integers (Bit Manipulation, Medium)

**🔗 Link:** [LeetCode 371 - Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/)
**🟢 Status:** ✅ Solved

---

## 🔹 Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Use **bitwise XOR** for sum and **bitwise AND + left shift** for carry, repeat until carry is 0.
* **Core Concept:** **Bit Manipulation / Two’s Complement Representation**
* **When to Use This Pattern?** When addition/subtraction is restricted and you need to emulate arithmetic with bitwise operations.
* **Mistakes to Avoid:**

  * Forgetting to mask to 32 bits in Python (since it has unlimited integer size).
  * Assuming XOR alone is enough (it ignores carry bits).
  * Not handling negatives (needs two’s complement conversion).

---

## 🔹 Optimization Path

* **Brute Force:** Not applicable (since `+` and `-` are disallowed).
* **Optimized Solution:** Iterative carry propagation loop with **XOR + AND + shift**, masked to 32 bits.
* **Further Improvements Possible?** Recursive version works but iterative is cleaner and avoids recursion depth overhead.

---

## 🔹 Solution Breakdown

* **Optimal Approach:** Use XOR (`^`) for sum, AND (`&`) + shift for carry, keep looping until carry vanishes. Apply 32-bit mask for Python compatibility.
* **Why This Works?** Binary addition is just two rules:

  * Sum = XOR (ignoring carry)
  * Carry = AND shifted left
* Looping applies carry until nothing remains.
* **Edge Cases Considered:**

  * Negative numbers → handled via two’s complement masking.
  * Large values beyond 32-bit → masked down.
  * Zero input.

---

## 🔹 Pattern Recognition

* **Belongs To:** Bit Manipulation (carry propagation with XOR & AND).
* **Common Problems Using This:**

  * [136. Single Number](https://leetcode.com/problems/single-number/)
  * [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
  * [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)
  * [338. Counting Bits](https://leetcode.com/problems/counting-bits/)

---

## 🔹 Tricks & Patterns Used

* **XOR for sum** without carry.
* **AND + shift for carry** to next higher bit.
* **Masking** to emulate 32-bit overflow in Python.
* **Two’s Complement Conversion** for negative numbers.

---

## 🔹 Alternative Data Structures

Not applicable — this is a pure bitwise arithmetic trick.

---

## 🔹 Complexity Analysis

* **Time Complexity:** O(1) (bounded by bit-width, i.e., max 32 iterations).
* **Space Complexity:** O(1) (only a few variables).

---

## 🔹 Code Snippet (Optimized)

```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        mask = 0xFFFFFFFF  # 32-bit mask
        max_int = 0x7FFFFFFF  # Max positive int (2^31 - 1)

        while b != 0:
            carry = (a & b) << 1
            a = (a ^ b) & mask
            b = carry & mask

        return a if a <= max_int else ~(a ^ mask)

# ⏱ Time: O(1)
# 💾 Space: O(1)
```

---

✅ **Final Takeaway:** This problem trains you to think at the bit level, simulating addition without relying on built-in arithmetic. It’s a **must-have in your Bit Manipulation folder**.
