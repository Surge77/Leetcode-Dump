# ðŸ”¹ Problem Name: Lowest Common Ancestor of a Binary Search Tree (BST Navigation, Medium)

**ðŸ”— Link:** [LeetCode 235](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)
**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Use BST property to navigate towards the split point
* **Core Concept:** BST Property Navigation (left < root < right)
* **When to Use This Pattern?** When both nodes lie in a BST and you need their lowest common ancestor
* **Mistakes to Avoid:**

  * Thinking you must search both subtrees (not needed in BST)
  * Assuming LCA must be strictly above both nodes (it can be one of the nodes)
  * Forgetting iterative solutions exist (saves stack space)

---

## ðŸ”¹ Optimization Path

* **Naive Binary Tree:** DFS on both sides â†’ O(n) time, O(h) space
* **Recursive BST:** Use property to prune â†’ O(h) time, O(h) space
* **Optimized Iterative BST:** Navigate with one pointer â†’ O(h) time, O(1) space âœ…

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Iteratively traverse from root using BST property until nodes split or match root
* **Why This Works?** The first node where `p` and `q` diverge (or match) is their LCA
* **Edge Cases Considered:**

  * One node is ancestor of the other (return ancestor directly)
  * Both nodes on same side â†’ keep traversing
  * p == q â†’ return that node

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** BST Navigation + Tree Traversal
* **Common Problems Using This:** Range Sum in BST, Search in BST, Insert/Delete in BST, kth Smallest in BST

---

## ðŸ”¹ Tricks & Patterns Used

* **BST Pruning:** Skip half the tree each step based on values
* **Split Point Recognition:** When `p` and `q` are on different sides, current node = LCA

---

## ðŸ”¹ Alternative Data Structures

* Generic binary tree (no BST property) requires full DFS search
* Balanced BST ensures O(log n) traversal time

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(h) â€“ height of tree (O(log n) for balanced BST, O(n) worst case skewed)
* **Space Complexity:** O(1) â€“ iterative pointer, no recursion stack

---

## ðŸ”¹ Code Snippet (Optimized)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
        cur = root
    
        while cur:
            if p.val > cur.val and q.val > cur.val:
                cur = cur.right  # both nodes in right subtree
            elif p.val < cur.val and q.val < cur.val:
                cur = cur.left   # both nodes in left subtree
            else:
                return cur  # split point or match found

"""
ðŸ“Š ANALYSIS
â€¢ Time Complexity: O(h) - Traverse down tree height
â€¢ Space Complexity: O(1) - Iterative, no recursion
"""
```
