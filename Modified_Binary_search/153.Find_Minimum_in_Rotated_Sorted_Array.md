# ðŸ”¹ Problem Name: Find Minimum in Rotated Sorted Array (Binary Search, Medium)

**ðŸ”— Link:** [LeetCode Problem 153](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Modified Binary Search to find pivot (minimum element).
* **Core Concept:** Binary Search variant for rotated sorted arrays.
* **When to Use This Pattern?** When the array is sorted but rotated, and you need to find a min/max/pivot efficiently.
* **Mistakes to Avoid:**
  * Forgetting to check if the subarray is already sorted before searching.
  * Comparing with the wrong boundary (confusing `nums[l]` vs. `nums[r]`).
  * Not handling case when array is not rotated.

## ðŸ”¹ Optimization Path

* **Brute Force:** O(n) â€” Scan through entire array to find min.
* **Optimized Solution:** O(log n) using Modified Binary Search.
* **Further Improvements Possible?** No; O(log n) is optimal for this problem.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Use binary search to repeatedly check which half is sorted; if left is sorted, min is in right half; if right is sorted, min is in left half.
* **Why This Works?** In a rotated sorted array, one half is always sorted. The pivot (min) lies in the unsorted half unless the whole segment is sorted.
* **Edge Cases Considered:**
  * Array not rotated (already sorted)
  * Array rotated by n-1 positions
  * Only 1 element
  * Two elements swapped

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Modified Binary Search
* **Common Problems Using This:**
  * Search in Rotated Sorted Array
  * Find Peak Element
  * Minimum in Rotated Sorted Array II (with duplicates)

## ðŸ”¹ Tricks & Patterns Used

* **Binary Search boundary adjustments**
* **Early exit when sorted segment detected**
* **Pivot detection by comparing middle element to boundaries**

## ðŸ”¹ Alternative Data Structures

* No alternative DS needed; problem is best solved using index pointers.

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(log n)
* **Space Complexity:** O(1)

## ðŸ”¹ Code Snippet (Optimized)

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        res = nums[0]            # Tentative min
        l, r = 0, len(nums) - 1  # Binary search boundaries

        while l <= r:
            if nums[l] < nums[r]:
                res = min(res, nums[l])
                break

            m = (l + r) // 2
            res = min(res, nums[m])

            if nums[m] >= nums[l]:
                l = m + 1
            else:
                r = m - 1
        return res

# Time Complexity: O(log n)
# Space Complexity: O(1)
```
