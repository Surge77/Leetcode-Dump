# ðŸ”¹ Problem Name: 141. Linked List Cycle (Linked List / Fast & Slow Pointers, Easy)

**ðŸ”— Link:** [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** **Floydâ€™s Tortoise & Hare** â€” two pointers with different speeds
* **Core Concept:** If a cycle exists, the fast pointer (2Ã—) will eventually meet the slow pointer (1Ã—) inside the loop
* **When to Use This Pattern?**

    * Detecting cycles in linked lists or implicit pointer graphs (numbers/arrays treated as next-pointers)
* **Mistakes to Avoid:**

    1. Missing `while fast and fast.next` guard
    2. Thinking pointers can â€œskip pastâ€ each other â€” they must meet in a cycle
    3. Starting pointers at different nodes unnecessarily â€” starting together is fine

---

## ðŸ”¹ Optimization Path

* **Alternative:** HashSet of visited nodes â†’ **Time:** O(n), **Space:** O(n).
* **Optimized (Chosen):** **Fast & Slow Pointers** â†’ **Time:** O(n), **Space:** O(1).

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Move `slow` by 1 and `fast` by 2.

    * If `fast` hits `None`, no cycle.
    * If `slow == fast` at any point, a cycle exists.
* **Why This Works?** Inside a cycle, the relative speed is 1 node per step (2Ã— âˆ’ 1Ã—), guaranteeing a meeting in â‰¤ cycle length steps after both are in the loop.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** **#4 Fast & Slow Pointers**
* **Related Problems:** 142 (find cycle start), 876 (middle of list), 234 (palindrome list), 287 (duplicate number via cycle), 202 (happy number).

---

## ðŸ”¹ Tricks & Patterns Used

* Two runners (1Ã— and 2Ã—) to create deterministic relative motion.
* Early exit on `fast is None` or `fast.next is None`.

---

## ðŸ”¹ Alternative Data Structures

* HashSet for visited nodes (simple to reason about, extra space).

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** **O(n)** â€” each node is visited a constant number of times.
* **Space Complexity:** **O(1)** â€” only two pointers.

---

## ðŸ”¹ Code Snippet (Optimized â€” Floyd)

```python
# Time: O(n) â€” each node processed O(1) times
# Space: O(1) â€” two pointers only
from typing import Optional

# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def hasCycle(self, head: Optional['ListNode']) -> bool:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next          # 1Ã— speed
            fast = fast.next.next     # 2Ã— speed
            if slow == fast:
                return True           # met inside cycle
        return False                   # reached null â†’ no cycle
```

---

## ðŸ”¹ 80/20 Recall (8ty)

* Guard: `while fast and fast.next` â†’ move `slow` 1, `fast` 2 â†’ **meet â‡’ cycle**, **null â‡’ no cycle**.
