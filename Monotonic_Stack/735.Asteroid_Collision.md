# ðŸ”¹ Problem Name: Asteroid Collision (Stack Simulation, Medium)

**ðŸ”— Link:** [LeetCode 735 â€” Asteroid Collision](https://leetcode.com/problems/asteroid-collision/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Use a stack to keep track of surviving right-moving asteroids, and process left-moving asteroids by resolving all collisions with the stackâ€™s top until stable.
* **Core Concept:** **Stack-Based Collision Simulation** â€” only right-moving asteroids in the stack can collide with an incoming left-moving asteroid.
* **When to Use This Pattern?** When simulating sequential events where only certain conditions cause interactions and cascading effects.
* **Mistakes to Avoid (cm):**

  * Forgetting that only opposite directions collide (positive vs negative).
  * Not handling chain collisions where one asteroid destroys multiple others.
  * Not considering equal size collisions (both removed).

## ðŸ”¹ Optimization Path

* **Brute Force:** Simulate every movement step until no collisions â†’ **O(nÂ²)**.
* **Optimized Solution:** Stack simulation â€” each asteroid is pushed/popped at most once â†’ **O(n)** time, **O(n)** space.
* **Further Improvements Possible?** Algorithm is already optimal for this problem.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Iterate through asteroids:

  * If moving right (`>0`), push to stack.
  * If moving left (`<0`), pop from stack while the top is a smaller right-moving asteroid.
  * Handle equal size collisions by popping and discarding current asteroid.
  * Push the left-moving asteroid only if stack is empty or top is also left-moving.
* **Why This Works?** Stack naturally keeps track of active right-moving asteroids that can collide with future left-moving ones; cascade destruction handled via while loop.
* **Edge Cases Considered:**

  * No collisions (all same direction).
  * Equal size collisions.
  * Cascading collisions where one large asteroid wipes out many smaller ones.

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Pattern #8 â€” Monotonic Stack / Queue (Subpattern: Collision Simulation).
* **Common Problems Using This:** Remove Adjacent Duplicates, 1D Candy Crush, Backspace String Compare (stack simulation form).

## ðŸ”¹ Tricks & Patterns Used

* **State Tracking via Stack:** Store only possible collision candidates.
* **Cascade Handling:** While loop to handle chain collisions before final placement.

## ðŸ”¹ Alternative Data Structures

* Could use a deque for more complex two-ended collision scenarios, but here a simple stack suffices.

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) â€” each asteroid pushed/popped at most once.
* **Space Complexity:** O(n) â€” stack for survivors.

## ðŸ”¹ Code Snippet (Optimized)

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for asteroid in asteroids:
            if asteroid > 0:
                stack.append(asteroid)
            else:
                while stack and stack[-1] > 0 and stack[-1] < -asteroid:
                    stack.pop()
                if stack and stack[-1] == -asteroid:
                    stack.pop()
                elif not stack or stack[-1] < 0:
                    stack.append(asteroid)
        return stack

# Complexity:
# Time: O(n) â€” each asteroid processed at most twice
# Space: O(n) â€” stack for survivors
```

---

**Interview Power Move:**

> "I modeled the asteroid collisions as a stack simulation. Only right-moving asteroids are stored as potential collision candidates. Incoming left-moving asteroids resolve collisions in a while loop, supporting cascade destruction. Equal sizes cause mutual destruction, and unmatched left-movers are pushed. This keeps all operations O(1) amortized, for O(n) total time."
