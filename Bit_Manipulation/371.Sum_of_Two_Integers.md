# ðŸ”¹ Problem Name: Sum of Two Integers (Bit Manipulation, Medium)

**ðŸ”— Link:** [LeetCode 371 - Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/)
**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Use **bitwise XOR** for sum and **bitwise AND + left shift** for carry, repeat until carry is 0.
* **Core Concept:** **Bit Manipulation / Twoâ€™s Complement Representation**
* **When to Use This Pattern?** When addition/subtraction is restricted and you need to emulate arithmetic with bitwise operations.
* **Mistakes to Avoid:**

  * Forgetting to mask to 32 bits in Python (since it has unlimited integer size).
  * Assuming XOR alone is enough (it ignores carry bits).
  * Not handling negatives (needs twoâ€™s complement conversion).

---

## ðŸ”¹ Optimization Path

* **Brute Force:** Not applicable (since `+` and `-` are disallowed).
* **Optimized Solution:** Iterative carry propagation loop with **XOR + AND + shift**, masked to 32 bits.
* **Further Improvements Possible?** Recursive version works but iterative is cleaner and avoids recursion depth overhead.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Use XOR (`^`) for sum, AND (`&`) + shift for carry, keep looping until carry vanishes. Apply 32-bit mask for Python compatibility.
* **Why This Works?** Binary addition is just two rules:

  * Sum = XOR (ignoring carry)
  * Carry = AND shifted left
* Looping applies carry until nothing remains.
* **Edge Cases Considered:**

  * Negative numbers â†’ handled via twoâ€™s complement masking.
  * Large values beyond 32-bit â†’ masked down.
  * Zero input.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Bit Manipulation (carry propagation with XOR & AND).
* **Common Problems Using This:**

  * [136. Single Number](https://leetcode.com/problems/single-number/)
  * [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
  * [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)
  * [338. Counting Bits](https://leetcode.com/problems/counting-bits/)

---

## ðŸ”¹ Tricks & Patterns Used

* **XOR for sum** without carry.
* **AND + shift for carry** to next higher bit.
* **Masking** to emulate 32-bit overflow in Python.
* **Twoâ€™s Complement Conversion** for negative numbers.

---

## ðŸ”¹ Alternative Data Structures

Not applicable â€” this is a pure bitwise arithmetic trick.

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(1) (bounded by bit-width, i.e., max 32 iterations).
* **Space Complexity:** O(1) (only a few variables).

---

## ðŸ”¹ Code Snippet (Optimized)

```python
class Solution:
    def getSum(self, a: int, b: int) -> int:
        mask = 0xFFFFFFFF  # 32-bit mask
        max_int = 0x7FFFFFFF  # Max positive int (2^31 - 1)

        while b != 0:
            carry = (a & b) << 1
            a = (a ^ b) & mask
            b = carry & mask

        return a if a <= max_int else ~(a ^ mask)

# â± Time: O(1)
# ðŸ’¾ Space: O(1)
```

---

âœ… **Final Takeaway:** This problem trains you to think at the bit level, simulating addition without relying on built-in arithmetic. Itâ€™s a **must-have in your Bit Manipulation folder**.
