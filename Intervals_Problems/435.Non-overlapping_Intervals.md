# ðŸ”¹ Problem Name: Non-overlapping Intervals (Greedy, Medium)

**ðŸ”— Link:** [LeetCode â€” Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Greedy â€” sort by **end time** and accept non-overlapping intervals
* **Core Concept:** Activity Selection / Interval Scheduling
* **When to Use This Pattern?** When asked to **remove the fewest intervals** (or pick the most non-overlapping) from a set of intervals.
* **Mistakes to Avoid:**

  * Sorting by **start time** and trying to keep the earliest start (can still work with extra logic but is noisier).
  * Updating `prevEnd` during overlap (you should **discard the current** interval in this formulation).
  * Thinking greedy is not optimal here â€” it **is provably optimal** via exchange argument.

---

## ðŸ”¹ Optimization Path

* **Brute Force:** Try all subsets to keep max non-overlapping â†’ **O(2^n)** (impractical).
* **Optimized Solution:** Greedy by end-time sort â†’ **O(n log n)** due to sorting; single pass is O(n).
* **Further Improvements Possible?** If intervals are already nearly sorted or you have bucketed end-times (bounded coordinate range), you can reduce sorting overhead, but asymptotically **O(n log n)** is optimal for arbitrary inputs.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Sort by **end**; keep `prevEnd` of the last accepted interval. For each next interval, if it **overlaps** (`start < prevEnd`), count a removal; else accept it and update `prevEnd`.
* **Why This Works?** Choosing the interval that **finishes earliest** leaves the **maximum room** for future intervals â€” the classic greedy-choice property for activity selection.
* **Edge Cases Considered:**

  * Empty input `[]` â†’ result `0`.
  * Single interval â†’ `0`.
  * Touching intervals like `[1,2]` and `[2,3]` are **non-overlapping** (`start >= prevEnd`).
  * Many identical intervals â†’ keep just one, remove `k-1`.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Greedy â†’ Activity Selection / Interval Scheduling
* **Common Problems Using This:**

  * "Maximum number of non-overlapping intervals"
  * "Erase minimum to avoid overlaps" (this problem)
  * Scheduling talks/meetings with rooms (variant with resources)
  * Selecting maximum compatible activities

---

## ðŸ”¹ Tricks & Patterns Used

* Greedy with **end-time** sorting
* Overlap test: `curr.start < prevEnd`
* Implicit removal by **counting overlaps** instead of tracking kept intervals

---

## ðŸ”¹ Alternative Data Structures

* Not required. A simple sort + scalar state is enough.
* For massive data with bounded coordinates, counting sort/radix-like strategies could shave constants.

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** `O(n log n)` for sorting + `O(n)` scan â†’ **`O(n log n)`**.
* **Space Complexity:** **`O(1)`** extra (in-place sort allowed by languages may vary; Pythonâ€™s `.sort()` is `O(n)` memory stable but we count auxiliary vars as `O(1)`).

---

## ðŸ”¹ Code Snippet (Optimized)

```python
# Time:  O(n log n)  â€” sort dominates; single pass is O(n)
# Space: O(1) extra â€” tracking only prevEnd and removals (ignoring sort temp memory)
from typing import List

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        # Greedy foundation: sort by earliest finishing time
        intervals.sort(key=lambda pair: pair[1])

        prevEnd = intervals[0][1]
        removals = 0

        for i in range(1, len(intervals)):
            start_i, end_i = intervals[i]
            if start_i < prevEnd:  # overlap â†’ remove this interval
                removals += 1
                # do NOT update prevEnd; we keep the earlier finisher
            else:                   # non-overlap â†’ accept and advance boundary
                prevEnd = end_i

        return removals
```

---

## ðŸ”¹ Example Walkthrough

Input: `[[1,2],[2,3],[3,4],[1,3]]`
After end-time sort â†’ `[[1,2],[1,3],[2,3],[3,4]]`

* Compare `[1,3]`: `start=1 < prevEnd=2` â†’ remove (`removals=1`)
* Compare `[2,3]`: `2 >= 2` â†’ keep, `prevEnd=3`
* Compare `[3,4]`: `3 >= 3` â†’ keep, `prevEnd=4`
  **Answer:** `1`

---

## ðŸ”¹ 80/20 (8ty)

* **80% win:** Always sort by **end time**; accept non-overlaps.
* **20% finesse:** Donâ€™t overthink tracking the kept set â€” **count removals**. Equality (`start == prevEnd`) is **non-overlap**.

---

## ðŸ”¹ Common Misconceptions (cm)

* "Greedy wonâ€™t be optimal here" â†’ It **is** optimal; classic exchange argument.
* "Must track actual kept intervals" â†’ Counting removals is sufficient.
* "Sort by start time is better" â†’ It can work with extra logic (like `prevEnd = min(prevEnd, end)`), but **end-time sort** is the canonical proof-friendly path.

---

## ðŸ”¹ Further Notes / Variations

* If the task changes to **maximize** the number of intervals kept, return `kept = total - removals` directly.
* If intervals can be open/closed with different overlap semantics, adjust the comparison (`<` vs `<=`).
