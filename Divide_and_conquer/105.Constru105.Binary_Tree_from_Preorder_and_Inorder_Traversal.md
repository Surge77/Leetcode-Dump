# 🔹 Problem Name: Construct Binary Tree from Preorder and Inorder Traversal (Divide & Conquer, Medium)

**🔗 Link:** [LeetCode 105 — Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
**🟢 Status:** ✅ Solved

---

## 🔹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Divide and Conquer (Recursive Reconstruction from Traversal Slices).
* **Core Concept:** Binary Tree Traversal Reconstruction.
* **When to Use This Pattern?** When you have two different traversals (e.g., Preorder + Inorder) and must rebuild the exact tree structure.
* **Mistakes to Avoid:**

    * Forgetting base cases when lists are empty.
    * Using `.index()` inside recursion without memoization (leads to O(n²) time).
    * Mismanaging preorder slice indices when partitioning.

---

## 🔹 Optimization Path

* **Brute Force:** Slice preorder/inorder lists at every recursive step.
  **Time:** O(n²) due to repeated `.index()` calls.
  **Space:** O(n) for recursion stack + list slicing overhead.

* **Optimized Solution:** Precompute a hash map `{value: inorder_index}` and use start/end indices instead of slicing.
  **Time:** O(n) total — each node handled once.
  **Space:** O(n) (recursion + hashmap).

* **Further Improvements Possible?** Use iteration or stack-based simulation, but recursion is cleanest and intuitive.

---

## 🔹 Solution Breakdown

**Optimal Approach:**

1. Preorder gives the root first.
2. Find that root’s index in inorder → split left/right subtrees.
3. Recurse to build left and right halves.

**Why This Works:**
Preorder defines hierarchy (root first), and inorder defines structure (left-right distribution). Together, they uniquely determine the tree.

**Edge Cases Considered:**

* Empty lists → return `None`.
* Single node → return node directly.
* Duplicate values not allowed (per problem constraints).

---

## 🔹 Pattern Recognition

* **Belongs To:** Divide & Conquer (#6 in user’s pattern list)
* **Also Uses:** Recursion, Tree Construction, DFS
* **Common Problems Using This:**

    * [LC 106 — Construct from Inorder & Postorder](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
    * [LC 889 — Construct from Preorder & Postorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)
    * [LC 297 — Serialize & Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)

---

## 🔹 Tricks & Patterns Used

* **Divide:** Locate root in inorder → partition left/right.
* **Conquer:** Recurse to build subtrees.
* **Combine:** Link returned left/right roots to the parent.

---

## 🔹 Alternative Data Structures

* **Hash Map (Value → Index):** Speeds up index lookups from O(n) → O(1).
* **Queue / Iterator for Preorder:** Avoids manual slicing; simply consume elements in preorder order.

---

## 🔹 Complexity Analysis

* **Time Complexity (current code):** O(n²) due to `inorder.index()` inside recursion.
* **Optimized Time Complexity:** O(n) using hashmap precomputation.
* **Space Complexity:** O(n) recursion + auxiliary storage.

---

## 🔹 Code Snippet (Current Recursive Implementation)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from typing import List, Optional

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional['TreeNode']:
        if not preorder or not inorder:
            return None

        root = TreeNode(preorder[0])
        mid = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])
        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])
        return root
```

---

## 🔹 Optimized Version (Using Hash Map)

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional['TreeNode']:
        inorder_map = {val: idx for idx, val in enumerate(inorder)}
        self.pre_idx = 0

        def helper(left: int, right: int) -> Optional['TreeNode']:
            if left > right:
                return None

            root_val = preorder[self.pre_idx]
            self.pre_idx += 1

            root = TreeNode(root_val)
            mid = inorder_map[root_val]

            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(inorder) - 1)
```

**Time Complexity:** O(n)
**Space Complexity:** O(n)
**Key Improvement:** Avoids slicing; uses indices and a hash map.

---

## 🔹 Common Misconceptions (cm)

* “Inorder alone can rebuild the tree.” ❌ (Ambiguous — many trees share same inorder.)
* “Preorder defines both structure and order.” ❌ (You need inorder to know boundaries.)
* “Slicing is harmless.” ❌ (It’s costly: O(n) each recursion.)

---

## 🔹 80/20 Insight (8ty)

Focus on mastering **root identification and inorder partitioning** — that’s 80% of this problem. The rest (list slicing vs. hashmap) is optimization detail.

---

## 📊 ANALYSIS

Approach Used: Recursive Divide & Conquer on Preorder and Inorder partitions.
Each call isolates the current root (from preorder) and partitions the inorder list around it to build left/right subtrees recursively.

Complexity:
Time: O(n²) naive → O(n) optimized.
Space: O(n) recursion + auxiliary structures.

First Principles:
Tree structure is uniquely determined by Preorder (hierarchy) + Inorder (placement). Identify root → partition → recurse.

80/20 Insight:
Root-first logic (Preorder) + left-right boundaries (Inorder) rebuilds any tree with certainty. Hash map gives the biggest ROI optimization.

Misconceptions:
“Myth: Traversals are interchangeable.” → Truth: Only Pre+In or In+Post define unique trees.
“Trap: Slicing doesn’t cost much.” → It costs linear time every recursion.

Five Whys:
Why Preorder? → Root order.
Why Inorder? → Left-right structure.
Why divide arrays? → Isolate subtrees.
Why recursion? → Trees are recursive.
Why O(n²) initially? → Repeated lookups and slicing.

🚨 Verdict: Elegant Divide & Conquer — linear in logic, quadratic only in slicing; mastering traversal partitioning unlocks every tree reconstruction variant.

💡 Interview Power Move:
“Preorder gives you root order; inorder tells you where the root splits left/right. Recursively partition, and you rebuild the tree from its traversal DNA.”

Evolution Complete:
Naive: Linear scans + slices → O(n²).
Optimized: Index map + pointers → O(n).
Complete mastery: Template for any traversal-based reconstruction problem. ✅
