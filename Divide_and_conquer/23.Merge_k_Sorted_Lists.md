# ðŸ”¹ Problem Name: 23. Merge k Sorted Lists (Linked List / Divide & Conquer, Hard)

**ðŸ”— Link:** [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)

**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Hard
* **Main Approach:** **Iterative Divide & Conquer** (pairwise merges, bottom-up)
* **Core Concepts:** Two Pointers (for 2-list merge), Dummy Head (sentinel)
* **When to Use This Pattern?**

    * Merging many already **sorted** linked lists; need **optimal** time without recursion
* **Mistakes to Avoid:**

    1. Forgetting to handle **odd** number of lists in a level
    2. Not advancing `tail` after attaching a node
    3. Reallocating nodes (should **reuse** existing nodes)
    4. Returning `dummy` instead of **`dummy.next`**

---

## ðŸ”¹ Optimization Path

* **Brute Force:** Concatenate all nodes â†’ sort â†’ rebuild list

    * **Time:** O(N log N) â€¢ **Space:** O(N) (values or nodes collected)
* **Scanning Min Head Each Time:** Pick min across k heads per node

    * **Time:** O(NÂ·k) â€¢ **Space:** O(1)
* **Optimized (Chosen):** **Iterative Divide & Conquer** (pairwise merges by levels)

    * **Time:** **O(N log k)** â€¢ **Space:** **O(1)** extra (no recursion; reuses nodes) + O(k) list references
* **Alternative:** **Min-Heap / Priority Queue** (push heads, pop min, push next)

    * **Time:** **O(N log k)** â€¢ **Space:** O(k)

---

## ðŸ”¹ Solution Breakdown

* **Idea:** Merge lists in **pairs** each level: `(0,1), (2,3), ...` â†’ produce \~k/2 lists; repeat until one remains.
* **Why This Works?** Each level halves the number of lists â†’ **log k** levels; each node participates in one merge per level â†’ **N** total work per level â†’ overall **O(N log k)**.
* **Edge Cases:** Empty input `[]`, lists already `None`, highly unbalanced list lengths, duplicates.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** **#6 Divide & Conquer (Recursion on Halves)** â€” implemented **iteratively**
* **Uses:** **#3 Two Pointers** for merging two lists; **Dummy Head** sentinel
* **Alternative Pattern:** **#9 Topâ€‘K (Heaps)** for priority-queue solution

---

## ðŸ”¹ Tricks & Patterns Used

* **Level-by-level** merging with step `i += 2`
* **Dummy head** to simplify attachments
* **Reuse nodes** (no extra node allocations besides dummy)

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** **O(N log k)** where **N** is total nodes, **k** is number of lists
* **Space Complexity:** **O(1)** extra (iterative; not counting input/output lists) â€¢ **O(k)** for temporary list references per level

---

## ðŸ”¹ Code Snippet (Optimized â€” Iterative Divide & Conquer)

```python
# Time: O(N log k) â€” log k merge levels; each node processed once per level
# Space: O(1) extra (no recursion), plus O(k) references per level
from typing import List, Optional

# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional['ListNode']]) -> Optional['ListNode']:
        if not lists:
            return None

        while len(lists) > 1:
            merged = []
            for i in range(0, len(lists), 2):
                l1 = lists[i]
                l2 = lists[i + 1] if i + 1 < len(lists) else None
                merged.append(self._merge_two(l1, l2))
            lists = merged
        return lists[0]

    def _merge_two(self, a: Optional['ListNode'], b: Optional['ListNode']) -> Optional['ListNode']:
        dummy = tail = ListNode()
        while a and b:
            if a.val <= b.val:   # <= keeps stability across nodes from same list
                tail.next, a = a, a.next
            else:
                tail.next, b = b, b.next
            tail = tail.next
        tail.next = a or b
        return dummy.next
```

---

## ðŸ”¹ 80/20 Recall (8ty)

**Pairwise merge** lists each level â†’ number of lists halves â†’ **log k** levels; inside a merge, use **two pointers + dummy**; return **`dummy.next`**.
