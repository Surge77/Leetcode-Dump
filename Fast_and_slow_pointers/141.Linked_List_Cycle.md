# 🔹 Problem Name: 141. Linked List Cycle (Linked List / Fast & Slow Pointers, Easy)

**🔗 Link:** [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

**🟢 Status:** ✅ Solved

---

## 🔹Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** **Floyd’s Tortoise & Hare** — two pointers with different speeds
* **Core Concept:** If a cycle exists, the fast pointer (2×) will eventually meet the slow pointer (1×) inside the loop
* **When to Use This Pattern?**

    * Detecting cycles in linked lists or implicit pointer graphs (numbers/arrays treated as next-pointers)
* **Mistakes to Avoid:**

    1. Missing `while fast and fast.next` guard
    2. Thinking pointers can “skip past” each other — they must meet in a cycle
    3. Starting pointers at different nodes unnecessarily — starting together is fine

---

## 🔹 Optimization Path

* **Alternative:** HashSet of visited nodes → **Time:** O(n), **Space:** O(n).
* **Optimized (Chosen):** **Fast & Slow Pointers** → **Time:** O(n), **Space:** O(1).

---

## 🔹 Solution Breakdown

* **Optimal Approach:** Move `slow` by 1 and `fast` by 2.

    * If `fast` hits `None`, no cycle.
    * If `slow == fast` at any point, a cycle exists.
* **Why This Works?** Inside a cycle, the relative speed is 1 node per step (2× − 1×), guaranteeing a meeting in ≤ cycle length steps after both are in the loop.

---

## 🔹 Pattern Recognition

* **Belongs To:** **#4 Fast & Slow Pointers**
* **Related Problems:** 142 (find cycle start), 876 (middle of list), 234 (palindrome list), 287 (duplicate number via cycle), 202 (happy number).

---

## 🔹 Tricks & Patterns Used

* Two runners (1× and 2×) to create deterministic relative motion.
* Early exit on `fast is None` or `fast.next is None`.

---

## 🔹 Alternative Data Structures

* HashSet for visited nodes (simple to reason about, extra space).

---

## 🔹 Complexity Analysis

* **Time Complexity:** **O(n)** — each node is visited a constant number of times.
* **Space Complexity:** **O(1)** — only two pointers.

---

## 🔹 Code Snippet (Optimized — Floyd)

```python
# Time: O(n) — each node processed O(1) times
# Space: O(1) — two pointers only
from typing import Optional

# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def hasCycle(self, head: Optional['ListNode']) -> bool:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next          # 1× speed
            fast = fast.next.next     # 2× speed
            if slow == fast:
                return True           # met inside cycle
        return False                   # reached null → no cycle
```

---

## 🔹 80/20 Recall (8ty)

* Guard: `while fast and fast.next` → move `slow` 1, `fast` 2 → **meet ⇒ cycle**, **null ⇒ no cycle**.
