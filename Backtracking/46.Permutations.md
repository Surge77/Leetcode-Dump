# ğŸ”¹ Problem Name: Permutations (Backtracking, Medium)

**ğŸ”— Link:** [LeetCode 46. Permutations](https://leetcode.com/problems/permutations/)
**ğŸŸ¢ Status:** âœ… Solved

## ğŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Backtracking with in-place swapping
* **Core Concept:** Generating all permutations using DFS recursion
* **When to Use This Pattern?**
  * When all possible orderings/arrangements are required (permutations)
  * Input is small (n â‰¤ 8-10), elements are unique
  * Backtracking problems where you explore all choices at each step
* **Mistakes to Avoid:**
  * Not backtracking swaps (leading to corrupted input)
  * Appending the reference of the list instead of a copy
  * Missing base case (when idx == len(nums))

## ğŸ”¹ Optimization Path

* **Brute Force:** Generate all possible arrangements by inserting elements in every possible position (recursive insert method)
* **Optimized Solution:** In-place backtracking with swapping for O(1) extra space per call
* **Further Improvements Possible?**
  * Minor: Reduce memory churn by using generator/yield (advanced)
  * Cannot avoid O(n! Ã— n) time due to number of permutations

## ğŸ”¹ Solution Breakdown

* **Optimal Approach:** Use backtracking by swapping elements in-place starting from current index, recursively permuting the rest.
* **Why This Works?**
  * Swapping in-place ensures every unique ordering is generated without extra structures.
  * At each index, all possible choices are tried by swapping.
* **Edge Cases Considered:**
  * Empty input (returns [[]])
  * Single-element input ([1]) returns [[1]]
  * Duplicates not considered (would require extra deduplication)

## ğŸ”¹ Pattern Recognition

* **Belongs To:** Backtracking / DFS on arrays
* **Common Problems Using This:**
  * Letter Case Permutation
  * Subsets
  * N-Queens
  * Combination Sum

## ğŸ”¹ Tricks & Patterns Used

* **In-place Backtracking:** Swap/revert to explore all arrangements efficiently
* **Base Case:** When the pointer reaches the end, record a permutation
* **O(1) Swap:** Swapping avoids need for visited/used arrays

## ğŸ”¹ Alternative Data Structures

* **Can this problem be optimized using a different DS?**
  * For duplicates: Use a set to avoid repeated permutations
  * For k-permutations: Use a used[] boolean array instead of in-place swaps
  * For large n: Consider iterative next\_permutation method (not practical for interviews)

## ğŸ”¹ Complexity Analysis

* **Time Complexity:** O(n! Ã— n)
  * n! permutations, each copied in O(n)
* **Space Complexity:** O(n) auxiliary (recursion depth); O(n! Ã— n) for result

## ğŸ”¹ Code Snippet (Optimized)

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.res = []
        self.backtrack(nums, 0)
        return self.res

    def backtrack(self, nums: List[int], idx: int):
        if idx == len(nums):
            self.res.append(nums[:])
            return
        for i in range(idx, len(nums)):
            nums[idx], nums[i] = nums[i], nums[idx]    # Swap
            self.backtrack(nums, idx + 1)              # Recurse
            nums[idx], nums[i] = nums[i], nums[idx]    # Backtrack
```
