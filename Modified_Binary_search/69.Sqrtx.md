# 🔹 Problem Name: Sqrt(x) (Math/Binary Search, Easy)

**🔗 Link:** [LeetCode 69 — Sqrt(x)](https://leetcode.com/problems/sqrtx/)
**🟢 Status:** ✅ Solved

---

## 🔹Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Binary Search over the integer range $0, x$ to find the largest `m` with `m*m ≤ x`.
* **Core Concept:** Monotonic predicate on `m`: `m*m ≤ x` flips from true→false exactly once ⇒ perfect for binary search.
* **When to Use This Pattern?**
  Use binary search when you can phrase the problem as: *find the boundary (max/min) index/value that satisfies a monotone condition*. Here: "is `m*m ≤ x`?"
* **Mistakes to Avoid:**

    1. Off-by-one on bounds (`left ≤ right` vs `left < right`).
    2. Not storing the best candidate (floor) when `m*m < x`.
    3. Overflow in other languages when computing `m*m` (use `long`/`64-bit` or compare as `m ≤ x/m`).

---

## 🔹 Optimization Path

* **Brute Force:** Test `i*i` from 1 upward until `i*i > x`.
  **Time:** O($\sqrt{x}$)
  **Space:** O(1)
* **Optimized Solution (Binary Search):** Search `m` in $0, x$. Track best answer when `m*m < x`.
  **Time:** O(log x)
  **Space:** O(1)
* **Further Improvements Possible?**
  **Newton’s Method** (a.k.a. Babylonian method): converge to $\sqrt{x}$ with quadratic convergence.
  **Time:** Typically O(log log x) iterations, fast in practice.
  **Space:** O(1).
  Ref: [Newton's Method (Wikipedia)](https://en.wikipedia.org/wiki/Newton%27s_method)

---

## 🔹 Solution Breakdown

* **Optimal Approach:** Binary search on integers; maintain `result` as the floor candidate when `mid*mid < x`.
* **Why This Works?** `mid*mid` increases with `mid` (monotone). If `mid*mid > x`, true root is smaller → move `right`. If `< x`, it’s a valid floor candidate → move `left` up and store `mid`.
* **Edge Cases Considered:** `x=0`, `x=1`, perfect squares (e.g., 4, 9), large `x` (avoid overflow in non-Python langs), minimal bounds (`left=0`, `right=x`).

---

## 🔹 Pattern Recognition

* **Belongs To:** Modified Binary Search (a.k.a. boundary finding).
* **Common Problems Using This:**

    * [367. Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/) — check if `n` is a perfect square via binary search.
    * [278. First Bad Version](https://leetcode.com/problems/first-bad-version/) — boundary search (first true).
    * [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/) — lower bound variant.
    * [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/) — binary search on answer (speed).

---

## 🔹 Tricks & Patterns Used

* **Binary Search Boundary Pattern:** Maintain invariant that `result` is last seen valid candidate.
* **Overflow Guard (Non-Python):** Compare as `mid <= x / mid` or cast to 64-bit before squaring.
* **Mid Calculation:** `mid = left + (right-left)//2` — avoids overflow in fixed-width integer languages.

---

## 🔹 Alternative Data Structures

* Not needed. Problem is numeric & monotone; DS won’t beat binary search here.
* Math alternative: Newton’s method (iterative numeric technique) instead of DS.

---

## 🔹 Complexity Analysis

* **Time Complexity:** O(log x) — halves the search space each iteration.
* **Space Complexity:** O(1) — constant auxiliary storage.

---

## 🔹 Code Snippet (Optimized — Binary Search)

```python
# Time: O(log x)
# Space: O(1)
class Solution:
    def mySqrt(self, x: int) -> int:
        left, right = 0, x
        result = 0
        while left <= right:
            mid = left + (right - left) // 2
            sq = mid * mid
            if sq > x:
                right = mid - 1
            elif sq < x:
                result = mid  # best floor candidate so far
                left = mid + 1
            else:
                return mid  # perfect square
        return result  # floor when no exact square
```

<details>
<summary>Alternate: Newton’s Method (fast in practice)</summary>

```python
# Time: ~O(log log x) iterations; Space: O(1)
class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:
            return x
        r = x  # initial guess
        while r * r > x:
            r = (r + x // r) // 2  # integer Newton step
        return r
```

**Note:** The integer variant uses `//` to keep guesses integral and naturally converges to the floor.

</details>

---

## 🔹 Common Misconceptions (cm)

* **“Must try numbers from 0 to x.”** Linear scan is unnecessary; monotonicity enables O(log x).
* **“Order of checks doesn’t matter.”** You must store the candidate when `mid*mid < x`, else you’ll lose the floor.
* **“Overflow isn’t a concern.”** In C++/Java, `mid*mid` can overflow `int`; use `long` or compare as `mid <= x/mid`.
* **“Left/right boundaries don’t matter.”** Wrong bounds or loop condition causes off-by-one bugs.

---

## 🔹 80/20 (8ty)

* The 20% that gives 80% wins:

    1. Frame as boundary search on a monotone predicate.
    2. Maintain `result` for floor.
    3. Use safe mid & overflow-aware comparisons.

---

## 🔹 Related Reading

* [Binary Search — LeetCode Explore Card](https://leetcode.com/explore/learn/card/binary-search/)
* [Newton’s Method — Wikipedia](https://en.wikipedia.org/wiki/Newton%27s_method)

---

## 🔹 Test Trace Example (x = 10)

* `left=0, right=10 → mid=5 → 25>10 → right=4`
* `left=0, right=4 → mid=2 → 4<10 → result=2, left=3`
* `left=3, right=4 → mid=3 → 9<10 → result=3, left=4`
* `left=4, right=4 → mid=4 → 16>10 → right=3`
* Loop ends (`left>right`), return **3**.

---

## 🔹 Interview Power Move

> “Model `m*m ≤ x` as a monotone predicate and binary-search the boundary. Store `mid` when valid to get the floor; use safe mid and overflow checks.”
