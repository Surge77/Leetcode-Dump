# ğŸ”¹ Problem Name: Counting Bits (Dynamic Programming + Bit Manipulation, Easy)

**ğŸ”— Link:** [LeetCode 338 - Counting Bits](https://leetcode.com/problems/counting-bits/)
**ğŸŸ¢ Status:** âœ… Solved

---

## ğŸ”¹ Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** **Dynamic Programming (DP)** with bitwise recurrence.
* **Core Concept:** Use the relation `dp[i] = dp[i >> 1] + (i & 1)`.
* **When to Use This Pattern?** When you need bit counts for all numbers up to `n`.
* **Mistakes to Avoid:**

  * Overcomplicating by scanning every bit of every number.
  * Forgetting that `i >> 1` effectively drops the least significant bit.
  * Misunderstanding `(i & 1)` as something other than â€œis the last bit set?â€

---

## ğŸ”¹ Optimization Path

* **Naive:** For each number, count bits with shifting/AND. O(n * 32).
* **Better:** Use Brian Kernighanâ€™s per-number bit count. O(n * k), where k = set bits.
* **Optimized Solution (This):** DP recurrence using `i >> 1`. O(n).
* **Further Improvements Possible?** Not much; this is optimal in both time and clarity.

---

## ğŸ”¹ Solution Breakdown

* **Optimal Approach:** `dp[i] = dp[i >> 1] + (i & 1)`.
* **Why This Works?**

  * `i >> 1` removes the last bit â†’ reuses precomputed bit count.
  * `(i & 1)` checks if the last bit is 1 â†’ add 1 if set.
* **Edge Cases Considered:**

  * n = 0 â†’ returns [0].
  * Works for all positive integers up to constraints (10^5 or higher).

---

## ğŸ”¹ Pattern Recognition

* **Belongs To:** Dynamic Programming + Bit Manipulation.
* **Common Problems Using This:**

  * [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
  * [231. Power of Two](https://leetcode.com/problems/power-of-two/)
  * [190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)
  * [401. Binary Watch](https://leetcode.com/problems/binary-watch/)

---

## ğŸ”¹ Tricks & Patterns Used

* **Right shift (`>>`)** to reuse smaller subproblems.
* **Bitwise AND (`& 1`)** to detect last bit.
* **DP recurrence** to avoid redundant calculations.

---

## ğŸ”¹ Alternative Data Structures

Not applicable â€” DP array + integers suffice.

---

## ğŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) â†’ single pass.
* **Space Complexity:** O(n) â†’ DP array.

---

## ğŸ”¹ Code Snippet (Optimized)

```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(n + 1):
            dp[i] = dp[i >> 1] + (i & 1)
        return dp

# â± Time: O(n)
# ğŸ’¾ Space: O(n)
```

---

âœ… **Final Takeaway:** Counting Bits shines as a **DP + bitwise hybrid**: reuse half-sized subproblems with a single recurrence, yielding a clean O(n) solution thatâ€™s both elegant and efficient.
