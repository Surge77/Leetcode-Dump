# ðŸ”¹ Problem Name: Same Tree (Binary Tree, Easy)

**ðŸ”— Link:** [LeetCode 100 - Same Tree](https://leetcode.com/problems/same-tree/)
**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Compare nodes of both trees synchronously (recursively or iteratively)
* **Core Concept:** Binary Tree traversal & pairwise node comparison
* **When to Use This Pattern?** When asked to check structural & value equality of two trees.
* **Mistakes to Avoid:**

  * Forgetting to check both `None` together.
  * Checking values before null-check.
  * Assuming iterative = less space (stack depth â‰ˆ recursion depth).

---

## ðŸ”¹ Optimization Path

* **Brute Force:** Traverse both trees into arrays and compare â†’ O(n) time, O(n) space.
* **Optimized Solution:** Direct recursive/iterative comparison â†’ O(n) time, O(h) space.
* **Further Improvements Possible?** Not really â€” fundamental lower bound requires visiting every node.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** DFS (recursion or manual stack) comparing nodes pairwise.
* **Why This Works?** Two trees are identical if roots match **and** left subtrees match **and** right subtrees match.
* **Edge Cases Considered:** Empty trees, one empty and one non-empty, single-node mismatch.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Tree Traversal + Structural Comparison
* **Common Problems Using This:** Subtree check, Symmetric Tree, Mirror Tree.

---

## ðŸ”¹ Tricks & Patterns Used

* Explicit stack simulation of recursion.
* Early termination on mismatch.
* Continue pattern for `(None, None)` pairs.

---

## ðŸ”¹ Alternative Data Structures

* **Queue (BFS):** Compare level by level instead of DFS.
* **Serialization (Preorder w/ null markers):** Serialize both and compare strings.

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) â†’ each node compared once.
* **Space Complexity:** O(h) â†’ recursion/stack depth, worst-case O(n).

---

## ðŸ”¹ Code Snippet (Optimized Iterative)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        stack = [(p, q)]  # Start with root pair
    
        while stack:
            node1, node2 = stack.pop()
        
            if not node1 and not node2:
                continue  # Both None â†’ identical so far
        
            if not node1 or not node2 or node1.val != node2.val:
                return False  # Mismatch found
        
            # Add children pairs
            stack.append((node1.right, node2.right))
            stack.append((node1.left, node2.left))
    
        return True

"""
Complexity:
Time: O(n) - Must compare all nodes
Space: O(h) - Stack/recursion depth
"""
```
