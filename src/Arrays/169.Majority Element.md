# ðŸ”¹ Problem Name: Majority Element (Array, Easy)

**ðŸ”— Link:**[LeetCode 169 - Majority Element](https://leetcode.com/problems/majority-element/description/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Boyer-Moore Voting Algorithm
* **Core Concept:** Majority element occurs more than âŒŠn / 2âŒ‹ times, so a candidate tracking system can be used to find it efficiently.
* **When to Use This Pattern?** When asked to find the most frequent element in an array with a guaranteed majority presence.
* **Mistakes to Avoid:**
  * Forgetting that the problem guarantees a majority element.
  * Using sorting or HashMap unnecessarily when an O(n) solution exists.

## ðŸ”¹ Optimization Path

* **Brute Force:** O(nÂ²) (Check each element's frequency)
* **Optimized Solution:** O(n) (Boyer-Moore Voting Algorithm)
* **Further Improvements Possible?** If we were not guaranteed a majority element, we would need an extra verification step.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Use a counter to track a majority candidate and adjust votes dynamically.
* **Why This Works?** Since the majority element appears more than âŒŠn / 2âŒ‹ times, all other elements combined cannot cancel its votes.
* **Edge Cases Considered:**
  * Already sorted array
  * Array with all identical elements
  * Minimum input size (n = 1)

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Greedy, Voting Algorithm
* **Common Problems Using This:**
  * [LeetCode 229 - Majority Element II](https://leetcode.com/problems/majority-element-ii/description/) (Find elements appearing more than âŒŠn / 3âŒ‹ times)

## ðŸ”¹ Tricks & Patterns Used

* **Boyer-Moore Voting Algorithm** (Efficient tracking of majority without extra space)

## ðŸ”¹ Alternative Data Structures

* **Can this problem be optimized using a different DS?**
  * A **HashMap** can count occurrences, but it increases space complexity to O(n).
  * **Sorting** can help, but it results in O(n log n) complexity.

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(n) (Single pass through the array)
* **Space Complexity:** O(1) (No extra storage used)

## ðŸ”¹ Code Snippet (Optimized)

```java
class Solution {
    public int majorityElement(int[] nums) {

        // Step 1: Assume the first element is the majority candidate.
        int majority = nums[0], votes = 1;

        // Step 2: Iterate through the array to adjust the majority candidate.
        for(int i = 1; i < nums.length; i++){

            // If votes are zero, we reset the majority candidate.
            if(votes == 0){
                votes++; // A new candidate gets an initial vote.
                majority = nums[i]; // Assume the current element as the new majority candidate.
            }
            // If the current element matches the majority candidate, increase the vote count.
            else if(majority == nums[i]){
                votes++;
            }
            // If the current element is different, decrease the vote count.
            else{
                votes--;
            }
        }

        // Step 3: The remaining candidate is the majority element.
        return majority;
    }
}
```
