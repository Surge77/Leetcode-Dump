# ðŸ”¹ Problem Name: 98. Validate Binary Search Tree (Tree, Medium)

**ðŸ”— Link:** [LeetCode â€“ Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)

### ðŸ§© Question Title

Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows:

* The left subtree of a node contains only nodes with keys less than the node's key.
* The right subtree of a node contains only nodes with keys greater than the node's key.
* Both the left and right subtrees must also be binary search trees.

**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Use DFS or BFS traversal with boundary limits (min, max).
* **Core Concept:** Binary Search Tree (BST) property validation â€” all left subtree values < node < all right subtree values.
* **When to Use This Pattern?** Whenever you need to check if a tree satisfies BST constraints globally, not just locally.
* **Mistakes to Avoid:**

    * Only comparing immediate children instead of maintaining valid min/max range.
    * Forgetting that all nodes in left subtree must be < root (not just direct left child).

## ðŸ”¹ Optimization Path

* **Brute Force:** Perform inorder traversal, collect all values, and check if the list is sorted strictly increasing â€” **O(N)** time, **O(N)** space.
* **Optimized Solution:** Use DFS or BFS keeping valid value range for each node â€” **O(N)** time, **O(H)** space (H = height of tree).
* **Further Improvements Possible?** None beyond this; itâ€™s already optimal.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Use an iterative BFS traversal while tracking each node's valid min/max range.
* **Why This Works?** Every node must satisfy `min < node.val < max`, and as we traverse, we tighten the constraints for subtrees.
* **Edge Cases Considered:**

    * Empty tree (`root = None`) â†’ valid BST.
    * Single-node tree â†’ valid BST.
    * Duplicates (e.g., node with same value as parent) â†’ invalid BST.

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Tree Traversal (DFS / BFS), Divide & Conquer.
* **Common Problems Using This:**

    * [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)
    * [173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)
    * [99. Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)

## ðŸ”¹ Tricks & Patterns Used

* **Bounded Recursion / Range Propagation:** Pass valid `(min, max)` bounds to child nodes.
* **Iterative BFS Variant:** Instead of recursion, use a queue for level-order validation.

## ðŸ”¹ Alternative Data Structures

* **Alternative:** Use stack for DFS validation instead of queue.
* **Example:** Replace `deque` with stack for in-order traversal validation.

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** O(N) â€” each node is visited once.
* **Space Complexity:** O(H) â€” height of tree, worst-case O(N) for skewed trees.

## ðŸ”¹ Code Snippet (Optimized)

```python
from collections import deque
from typing import Optional

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        q = deque([(root, float('-inf'), float('inf'))])

        while q:
            node, left, right = q.popleft()
            if not (left < node.val < right):
                return False
            if node.left:
                q.append((node.left, left, node.val))
            if node.right:
                q.append((node.right, node.val, right))

        return True
```

## ðŸ”¹ Analysis Block

```
ðŸ“Š ANALYSIS
Approach: Iterative BFS with value bounds (min, max) for each node.
Complexity: O(N) time | O(H) space.
First Principles: Each node defines a local rule (<root and >root) that propagates globally through recursion or iteration.
80/20 Insight: 80% of validation errors occur when developers forget to maintain global constraints across subtrees.
Misconceptions: Comparing only direct children satisfies local ordering but misses deep violations.
Five Whys:
1. Why not just compare children? â†’ Because deeper nodes can violate BST property.
2. Why use bounds? â†’ They maintain the valid numeric range for each subtree.
3. Why BFS/DFS works? â†’ Each traversal propagates constraints independently.
4. Why not inorder sort check? â†’ Itâ€™s simpler but uses extra space.
5. Why iterative BFS? â†’ Avoids recursion depth limits.
Verdict: Clean, optimal, and robust.
Pattern Magic: Tree Traversal + Divide & Conquer logic fused via constraint propagation.
Interview Power Move: Talk about how local rules fail without global range propagation.
Evolution Complete: âœ… Balanced between clarity and efficiency.
```
