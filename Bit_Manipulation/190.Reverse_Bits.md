# 🔹 Problem Name: Reverse Bits (Bit Manipulation, Easy)

**🔗 Link:** [LeetCode 190 - Reverse Bits](https://leetcode.com/problems/reverse-bits/)
**🟢 Status:** ✅ Solved

---

## 🔹 Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** Divide-and-conquer bit reversal using **mask-and-swap technique**.
* **Core Concept:** **Bit Manipulation** with shifting and masking.
* **When to Use This Pattern?** When asked to reverse the order of bits in a 32-bit integer efficiently.
* **Mistakes to Avoid:**

  * Assuming reversal must be done one bit at a time.
  * Thinking mask constants are arbitrary — each mask isolates a specific group.
  * Forgetting to apply `& 0xFFFFFFFF` to constrain to 32 bits in Python.

---

## 🔹 Optimization Path

* **Naive:** Convert to binary string, reverse, and parse back. O(32).
* **Better:** Iteratively shift and build result bit-by-bit. O(32).
* **Optimized Solution (This):** Mask and swap progressively smaller groups. O(log n) = O(1) for fixed 32 bits.
* **Further Improvements Possible?** Lookup tables for 8-bit chunks can optimize repeated calls.

---

## 🔹 Solution Breakdown

* **Optimal Approach:** Swap halves, then bytes, then nibbles, then bit pairs, then single bits using masks and shifts.
* **Why This Works?** Each step doubles the granularity of reversal:

  * Swap 16-bit halves → res halves flipped.
  * Swap 8-bit chunks (bytes) → order reversed further.
  * Swap 4-bit groups (nibbles), 2-bit pairs, then single bits.
* **Edge Cases Considered:**

  * Input = 0 (remains 0).
  * Input = all 1s (remains all 1s).
  * Works for any 32-bit integer input.

---

## 🔹 Pattern Recognition

* **Belongs To:** Bit Manipulation (Mask & Swap Tricks).
* **Common Problems Using This:**

  * [191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)
  * [231. Power of Two](https://leetcode.com/problems/power-of-two/)
  * [338. Counting Bits](https://leetcode.com/problems/counting-bits/)
  * [476. Number Complement](https://leetcode.com/problems/number-complement/)

---

## 🔹 Tricks & Patterns Used

* **Mask and swap** strategy for progressive reversal.
* Predefined masks (`0xff00ff00`, `0xf0f0f0f0`, etc.) to isolate groups.
* Apply shifts in opposite directions for each mask.
* Constrain result with `& 0xFFFFFFFF` to fit 32-bit output.

---

## 🔹 Alternative Data Structures

* **Lookup table for bytes:** Precompute reversed values for 0–255 and combine results.

---

## 🔹 Complexity Analysis

* **Time Complexity:** O(1) → fixed 5 steps regardless of input.
* **Space Complexity:** O(1).

---

## 🔹 Code Snippet (Optimized)

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        res = n
        res = (res >> 16) | (res << 16) & 0xFFFFFFFF
        res = ((res & 0xff00ff00) >> 8) | ((res & 0x00ff00ff) << 8)
        res = ((res & 0xf0f0f0f0) >> 4) | ((res & 0x0f0f0f0f) << 4)
        res = ((res & 0xcccccccc) >> 2) | ((res & 0x33333333) << 2)
        res = ((res & 0xaaaaaaaa) >> 1) | ((res & 0x55555555) << 1)
        return res & 0xFFFFFFFF

# ⏱ Time: O(1)
# 💾 Space: O(1)
```

---

✅ **Final Takeaway:** Reverse Bits with **mask-and-swap** is a textbook example of bit-level divide-and-conquer, avoiding naive per-bit work for a highly efficient constant-time solution.
