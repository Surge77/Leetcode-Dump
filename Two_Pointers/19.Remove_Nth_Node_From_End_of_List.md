# ðŸ”¹ Problem Name: 19. Remove Nth Node From End of List (Linked List, Medium)

**ðŸ”— Link:** [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** **Two Pointers (fixed-gap / runner) + Dummy Head (sentinel)**
* **Core Concept:** Maintain an **n-step gap** between `fast` and `slow` so that when `fast` reaches the end, `slow` sits **just before** the node to delete
* **When to Use This Pattern?**

    * Delete kth-from-end, split at middle, or any problem requiring **relative positioning from the tail**
* **Mistakes to Avoid:**

    1. Using a gap of `n-1` (should be **n**)
    2. Starting `slow` at `head` (use a **dummy** before head to handle head deletion)
    3. Forgetting to check `fast` movement when creating the gap
    4. Returning `head` instead of **`dummy.next`**

---

## ðŸ”¹ Optimization Path

* **Two-Pass Length Method:** compute length, delete `(len-n+1)`th node

    * **Time:** O(n) â€¢ **Space:** O(1)
* **Optimized (Chosen):** **Single-Pass Two Pointers** with n-gap + dummy

    * **Time:** **O(n)** â€¢ **Space:** **O(1)**
* **Alternatives:** Stack (push nodes, pop n) or recursion (uses call stack)

---

## ðŸ”¹ Solution Breakdown

* **Idea:** Place `slow` on **dummy** and `fast` on **head**. Move `fast` **n** steps. Then advance both pointers until `fast` hits `None`. Now `slow.next` is the target node; bypass it.
* **Why This Works?** The **n-step gap** ensures that `slow` trails `fast` by exactly n nodes. When `fast` reaches the end, `slow` is positioned exactly before the node to remove.
* **Edge Cases:** Removing the head (`n == len`), single-node list, `n = 1`, duplicates.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** **#3 Two Pointers (Opposite-End / Adjacent variant)**
* **Helper Technique:** **Dummy Head** (sentinel) to simplify edge cases
* **Related Problems:** 876 (middle of list), 143 (reorder list), 234 (palindrome list second-half ops)

---

## ðŸ”¹ Tricks & Patterns Used

* **Dummy node** to avoid special-casing head removal
* **Fixed gap** creation: move `fast` exactly **n** steps first
* **Bypass deletion:** `slow.next = slow.next.next`

---

## ðŸ”¹ Alternative Data Structures

* Stack for nodes (simple but O(n) extra space)
* Recursion (elegant, but O(n) stack)

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** **O(n)** â€” one traversal
* **Space Complexity:** **O(1)** â€” constant extra pointers

---

## ðŸ”¹ Code Snippet (Optimized â€” Single Pass, Dummy + Gap)

```python
# Time: O(n) â€” single traversal with two pointers
# Space: O(1) â€” constant extra pointers
from typing import Optional

# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def removeNthFromEnd(self, head: Optional['ListNode'], n: int) -> Optional['ListNode']:
        dummy = ListNode(0, head)
        slow, fast = dummy, head

        # 1) Create fixed gap of n between fast and slow
        for _ in range(n):
            fast = fast.next

        # 2) Advance both until fast reaches the end
        while fast:
            slow = slow.next
            fast = fast.next

        # 3) Delete the target node (slow is just before it)
        slow.next = slow.next.next
        return dummy.next
```

---

## ðŸ”¹ 80/20 Recall (8ty)

**Dummy** â†’ move **fast n steps** â†’ move both to end â†’ **delete slow\.next** â†’ return **`dummy.next`**.
