# ðŸ”¹ Problem Name: 206. Reverse Linked List (Linked List, Easy)

**ðŸ”— Link:** [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹Quick Breakdown

* **Difficulty Level:** Easy
* **Main Approach:** **Two Pointers (adjacent)** â€” in-place pointer rewiring (`prev`, `curr`, `temp`)
* **Core Concept:** Flip `next` pointers one-by-one while preserving access to the remainder of the list
* **When to Use This Pattern?**

    * Reversing a full list or a segment (foundation for k-group, sublist reversals, palindrome checks)
* **Mistakes to Avoid:**

    1. Not storing `temp = curr.next` before rewiring (youâ€™ll lose the rest of the list)
    2. Returning `curr` at the end (itâ€™s `None`); the answer is **`prev`**
    3. Starting `prev = head` instead of `None` (new tail must point to `None`)

---

## ðŸ”¹ Optimization Path

* **Brute Force (Not preferred):** Build a new list or collect values then rebuild

    * **Time:** O(n)
    * **Space:** O(n) extra
* **Optimized Solution (Chosen):** **Iterative two-pointer** rewiring

    * **Time:** O(n)
    * **Space:** O(1)
* **Alternative:** **Recursive** reversal (elegant but uses call stack)

    * **Time:** O(n), **Space:** O(n)

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Traverse with `curr`; for each node, save `temp = curr.next`, set `curr.next = prev`, then slide `prev = curr`, `curr = temp`.
* **Why This Works?** Each step flips exactly one pointer; the invariant is that the portion before `curr` is already reversed and led by `prev`.
* **Edge Cases Considered:** Empty list, single node, very long lists (iterative avoids recursion depth).

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** **#3 Two Pointers** (adjacent/rolling variant) + in-place pointer manipulation
* **Common Problems Using This:** Reverse Linked List II (sublist), Reverse Nodes in k-Group, Palindrome Linked List (reverse second half), Reorder List

---

## ðŸ”¹ Tricks & Patterns Used

* Three-pointer dance: `temp = curr.next` â†’ `curr.next = prev` â†’ advance both pointers
* Return **`prev`** as the new head

---

## ðŸ”¹ Alternative Data Structures

* None required. Recursion uses the call stack implicitly; iterative is the interview default.

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** **O(n)** â€” each node visited once
* **Space Complexity:** **O(1)** â€” constant extra pointers (iterative)

---

## ðŸ”¹ Code Snippet (Optimized)

```python
# Time: O(n) â€” visit each node once
# Space: O(1) â€” constant extra pointers
from typing import Optional

# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def reverseList(self, head: Optional['ListNode']) -> Optional['ListNode']:
        prev, curr = None, head
        while curr:
            temp = curr.next      # 1) Save next before breaking link
            curr.next = prev      # 2) Flip pointer to reverse the edge
            prev = curr           # 3) Advance prev
            curr = temp           # 4) Advance curr
        return prev               # New head is original tail
```

---

## ðŸ”¹ 80/20 Recall (8ty)

`temp = curr.next` â†’ `curr.next = prev` â†’ slide (`prev = curr`, `curr = temp`) â†’ **return `prev`**.
