# ðŸ”¹ Problem Name: Min Stack (Design, Medium)

**ðŸ”— Link:** [LeetCode 155 â€” Min Stack](https://leetcode.com/problems/min-stack/)
**ðŸŸ¢ Status:** âœ… Solved

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Maintain constantâ€‘time `getMin()` by augmenting stack state. Two classic ways:

    1. **Auxiliary Min Stack** (two stacks).
    2. **Mathematical Encoding (one stack + current min)** â€” stores differences to recover previous mins.
* **Core Concept:** **Monotonic/Minâ€‘tracking Stack** â€” every push carries the minimum so far.
* **When to Use This Pattern?** When an API requires `push/pop/top/getMin` all in **O(1)**.
* **Mistakes to Avoid (cm):**

    * Only pushing to minâ€‘stack on strict `<` (breaks with duplicates on pop).
    * Forgetting to restore **previous min** when popping a value that set a new min.
    * Not handling empty `top()/pop()/getMin()` in custom code paths.

## ðŸ”¹ Optimization Path

* **Brute Force:** Keep a normal stack; compute `getMin()` by scanning all elements â†’ **O(n)** per `getMin`, **O(1)** others.
* **Optimized Solution (Twoâ€‘Stacks):** Keep a parallel `minStack` mirroring mins â†’ **O(1)** all ops, **O(n)** extra space.
* **Further Improvement (Chosen):** **Mathematical Encoding** with one stack + `min` â†’ **O(1)** all ops, **O(1)** extra space.

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** **Mathematical Encoding** â€” push encoded `val - currentMin`. If new value is a new min, the stored diff is **negative**; on pop, a negative diff signals you to recover the **previous min**.
* **Why This Works?** For any push:

    * If `val >= min`, store `diff = val - min (>=0)`; `top = min + diff`.
    * If `val < min`, store `diff = val - min (<0)` and update `min = val`; later when popping, **previousMin = currentMin - diff** (since `diff` is negative).
* **Edge Cases Considered:**

    * Large/negative integers (works; math is signâ€‘based, not magnitudeâ€‘restricted).
    * Duplicate minimums (handled because we encode every push relative to current min).
    * Empty stack operations (guard or follow LeetCode contract that calls are valid).

## ðŸ”¹ Pattern Recognition

* **Belongs To:** **Pattern #8 â€” Monotonic Stack / Queue** (subpattern: **Minâ€‘tracking / Augmented Stack**).
* **Common Problems Using This:** Max Stack, Min Queue via two minâ€‘stacks, Online Stock Span, Daily Temperatures (monotonic idea).

## ðŸ”¹ Tricks & Patterns Used

* **State Augmentation:** carry extra info to achieve O(1) queries.
* **Difference Encoding:** store `val - min` to detect/restore mins via sign.
* **API Guarantees:** maintain invariants so each method is constant time.

## ðŸ”¹ Alternative Data Structures

* **Two Stacks:** `(values, mins)` â€” simpler to reason about; space **O(n)**.
* **Single Stack of Pairs:** store `(val, minSoFar)` per node â€” space **O(2n)** conceptually.
* **Balanced BST/Heap:** not suited (canâ€™t support `pop/top` as standard stack semantics with O(1)).

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** **O(1)** for `push`, `pop`, `top`, `getMin`.
* **Space Complexity:** **O(1)** extra (beyond stored elements) with encoding; **O(n)** with auxiliary minâ€‘stack.

## ðŸ”¹ Code Snippet (Optimized â€” Mathematical Encoding)

```python
class MinStack:
    def __init__(self):
        self._min = float('inf')   # Current minimum
        self._s = []               # Encoded differences

    def push(self, val: int) -> None:
        if not self._s:            # First element
            self._s.append(0)      # Encode baseline
            self._min = val
        else:
            diff = val - self._min
            self._s.append(diff)
            if val < self._min:
                self._min = val    # New min set

    def pop(self) -> None:
        if not self._s:
            return                 # Or raise underflow
        diff = self._s.pop()
        if diff < 0:               # Popped value had set a new min
            # Recover previous minimum: prev = curr - diff (diff < 0)
            self._min = self._min - diff

    def top(self) -> int:
        # Assumes non-empty per LeetCode contract
        diff = self._s[-1]
        return self._min if diff <= 0 else self._min + diff

    def getMin(self) -> int:
        # Assumes non-empty per LeetCode contract
        return self._min

# Complexity:
# Time: O(1) for push/pop/top/getMin
# Space: O(1) extra (tracks only current minimum)
```

---

**Interview Power Move:**

> "I used **difference encoding** to compress previousâ€‘min state into the stack itself. Negative diffs mark a new minimum; on pop, I recover the previous min with `prevMin = currMin - diff`. This keeps **all ops O(1)** and reduces **extra space to O(1)** compared to the twoâ€‘stack design."
