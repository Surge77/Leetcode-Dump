# ğŸ”¹ Problem Name: Construct Binary Tree from Preorder and Inorder Traversal (Divide & Conquer, Medium)

**ğŸ”— Link:** [LeetCode 105 â€” Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
**ğŸŸ¢ Status:** âœ… Solved

---

## ğŸ”¹Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** Divide and Conquer (Recursive Reconstruction from Traversal Slices).
* **Core Concept:** Binary Tree Traversal Reconstruction.
* **When to Use This Pattern?** When you have two different traversals (e.g., Preorder + Inorder) and must rebuild the exact tree structure.
* **Mistakes to Avoid:**

    * Forgetting base cases when lists are empty.
    * Using `.index()` inside recursion without memoization (leads to O(nÂ²) time).
    * Mismanaging preorder slice indices when partitioning.

---

## ğŸ”¹ Optimization Path

* **Brute Force:** Slice preorder/inorder lists at every recursive step.
  **Time:** O(nÂ²) due to repeated `.index()` calls.
  **Space:** O(n) for recursion stack + list slicing overhead.

* **Optimized Solution:** Precompute a hash map `{value: inorder_index}` and use start/end indices instead of slicing.
  **Time:** O(n) total â€” each node handled once.
  **Space:** O(n) (recursion + hashmap).

* **Further Improvements Possible?** Use iteration or stack-based simulation, but recursion is cleanest and intuitive.

---

## ğŸ”¹ Solution Breakdown

**Optimal Approach:**

1. Preorder gives the root first.
2. Find that rootâ€™s index in inorder â†’ split left/right subtrees.
3. Recurse to build left and right halves.

**Why This Works:**
Preorder defines hierarchy (root first), and inorder defines structure (left-right distribution). Together, they uniquely determine the tree.

**Edge Cases Considered:**

* Empty lists â†’ return `None`.
* Single node â†’ return node directly.
* Duplicate values not allowed (per problem constraints).

---

## ğŸ”¹ Pattern Recognition

* **Belongs To:** Divide & Conquer (#6 in userâ€™s pattern list)
* **Also Uses:** Recursion, Tree Construction, DFS
* **Common Problems Using This:**

    * [LC 106 â€” Construct from Inorder & Postorder](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
    * [LC 889 â€” Construct from Preorder & Postorder](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)
    * [LC 297 â€” Serialize & Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)

---

## ğŸ”¹ Tricks & Patterns Used

* **Divide:** Locate root in inorder â†’ partition left/right.
* **Conquer:** Recurse to build subtrees.
* **Combine:** Link returned left/right roots to the parent.

---

## ğŸ”¹ Alternative Data Structures

* **Hash Map (Value â†’ Index):** Speeds up index lookups from O(n) â†’ O(1).
* **Queue / Iterator for Preorder:** Avoids manual slicing; simply consume elements in preorder order.

---

## ğŸ”¹ Complexity Analysis

* **Time Complexity (current code):** O(nÂ²) due to `inorder.index()` inside recursion.
* **Optimized Time Complexity:** O(n) using hashmap precomputation.
* **Space Complexity:** O(n) recursion + auxiliary storage.

---

## ğŸ”¹ Code Snippet (Current Recursive Implementation)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

from typing import List, Optional

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional['TreeNode']:
        if not preorder or not inorder:
            return None

        root = TreeNode(preorder[0])
        mid = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])
        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])
        return root
```

---

## ğŸ”¹ Optimized Version (Using Hash Map)

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional['TreeNode']:
        inorder_map = {val: idx for idx, val in enumerate(inorder)}
        self.pre_idx = 0

        def helper(left: int, right: int) -> Optional['TreeNode']:
            if left > right:
                return None

            root_val = preorder[self.pre_idx]
            self.pre_idx += 1

            root = TreeNode(root_val)
            mid = inorder_map[root_val]

            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(inorder) - 1)
```

**Time Complexity:** O(n)
**Space Complexity:** O(n)
**Key Improvement:** Avoids slicing; uses indices and a hash map.

---

## ğŸ”¹ Common Misconceptions (cm)

* â€œInorder alone can rebuild the tree.â€ âŒ (Ambiguous â€” many trees share same inorder.)
* â€œPreorder defines both structure and order.â€ âŒ (You need inorder to know boundaries.)
* â€œSlicing is harmless.â€ âŒ (Itâ€™s costly: O(n) each recursion.)

---

## ğŸ”¹ 80/20 Insight (8ty)

Focus on mastering **root identification and inorder partitioning** â€” thatâ€™s 80% of this problem. The rest (list slicing vs. hashmap) is optimization detail.

---

## ğŸ“Š ANALYSIS

Approach Used: Recursive Divide & Conquer on Preorder and Inorder partitions.
Each call isolates the current root (from preorder) and partitions the inorder list around it to build left/right subtrees recursively.

Complexity:
Time: O(nÂ²) naive â†’ O(n) optimized.
Space: O(n) recursion + auxiliary structures.

First Principles:
Tree structure is uniquely determined by Preorder (hierarchy) + Inorder (placement). Identify root â†’ partition â†’ recurse.

80/20 Insight:
Root-first logic (Preorder) + left-right boundaries (Inorder) rebuilds any tree with certainty. Hash map gives the biggest ROI optimization.

Misconceptions:
â€œMyth: Traversals are interchangeable.â€ â†’ Truth: Only Pre+In or In+Post define unique trees.
â€œTrap: Slicing doesnâ€™t cost much.â€ â†’ It costs linear time every recursion.

Five Whys:
Why Preorder? â†’ Root order.
Why Inorder? â†’ Left-right structure.
Why divide arrays? â†’ Isolate subtrees.
Why recursion? â†’ Trees are recursive.
Why O(nÂ²) initially? â†’ Repeated lookups and slicing.

ğŸš¨ Verdict: Elegant Divide & Conquer â€” linear in logic, quadratic only in slicing; mastering traversal partitioning unlocks every tree reconstruction variant.

ğŸ’¡ Interview Power Move:
â€œPreorder gives you root order; inorder tells you where the root splits left/right. Recursively partition, and you rebuild the tree from its traversal DNA.â€

Evolution Complete:
Naive: Linear scans + slices â†’ O(nÂ²).
Optimized: Index map + pointers â†’ O(n).
Complete mastery: Template for any traversal-based reconstruction problem. âœ…
