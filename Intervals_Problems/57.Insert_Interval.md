# ðŸ”¹ Problem Name: Insert Interval (Greedy Merge, Medium)

**ðŸ”— Link:** [LeetCode â€” Insert Interval](https://leetcode.com/problems/insert-interval/)
**ðŸŸ¢ Status:** âœ… Solved

---

## ðŸ”¹ Quick Breakdown

* **Difficulty Level:** Medium
* **Main Approach:** One-pass **three-case** linear scan (before / after / overlap)
* **Core Concept:** Interval insertion with inline merging
* **When to Use This Pattern?** When intervals are **sorted and non-overlapping** and you must insert a new interval and return the merged result.
* **Mistakes to Avoid:**

  * Sorting again after insertion (unnecessary).
  * Delaying merge to the end (you can merge **inline** by expanding `newInterval`).
  * Forgetting early return when `newInterval` ends **before** current interval starts.

---

## ðŸ”¹ Optimization Path

* **Brute Force:** Append `newInterval`, **sort**, then full merge pass â†’ **O(n log n)**.
* **Optimized Solution:** **Single pass** over sorted intervals; expand `newInterval` upon overlaps; early return for before-case â†’ **O(n)** time.
* **Further Improvements Possible?** Binary search to find the first potential overlap can reduce constant factors but remains **O(n)** worst-case.

---

## ðŸ”¹ Solution Breakdown

* **Optimal Approach:** Scan from left to right:

  1. If `newInterval.end < curr.start` â†’ insert `newInterval` here, **return** result + remaining intervals.
  2. Else if `newInterval.start > curr.end` â†’ push `curr` to result.
  3. Else â†’ **overlap**; set `newInterval = [min(starts), max(ends)]` and continue.
     At the end, append `newInterval` if not placed.
* **Why This Works?** Intervals are already sorted and disjoint, so relative position is determined by endpoint comparisons. Inline expansion guarantees all overlapping neighbors are absorbed in one span.
* **Edge Cases Considered:**

  * Empty intervals list.
  * New interval completely before all or after all.
  * New interval swallowed by an existing one or vice versa.
  * Chains of adjacent overlaps (e.g., `[3,5]`, `[6,7]`, `[8,10]` with `new=[4,8]`).
  * Touching endpoints are **non-overlapping** under closed-open semantics if required; here we treat `end < start` as strict for the before-case.

---

## ðŸ”¹ Pattern Recognition

* **Belongs To:** Greedy / Interval Merging
* **Common Problems Using This:**

  * Merge Intervals
  * Non-overlapping Intervals (erase minimum)
  * Meeting Rooms (variants)
  * Insert/Delete interval operations

---

## ðŸ”¹ Tricks & Patterns Used

* Three-case decision machine (before / after / overlap)
* **Inline merge** by expanding `newInterval` with `min`/`max`
* **Early return** when insertion point found

---

## ðŸ”¹ Alternative Data Structures

* Not required. Simple list accumulation is sufficient.
* For huge datasets with bounded endpoints, bucketing could help constants; asymptotics unchanged.

---

## ðŸ”¹ Complexity Analysis

* **Time Complexity:** **`O(n)`** â€” single linear scan; early exit possible.
* **Space Complexity:** **`O(n)`** â€” result list stores merged intervals.

---

## ðŸ”¹ Code Snippet (Optimized)

```python
# Time:  O(n) â€” single pass over intervals
# Space: O(n) â€” output list accumulation
from typing import List

class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []

        for i in range(len(intervals)):
            # Case 1: new interval ends before current starts â†’ insert and finish
            if newInterval[1] < intervals[i][0]:
                res.append(newInterval)
                return res + intervals[i:]

            # Case 2: new interval starts after current ends â†’ keep current
            elif newInterval[0] > intervals[i][1]:
                res.append(intervals[i])

            # Case 3: overlap â†’ merge by expanding boundaries
            else:
                newInterval = [
                    min(newInterval[0], intervals[i][0]),
                    max(newInterval[1], intervals[i][1]),
                ]

        # If no earlier insertion, new interval goes at the end
        res.append(newInterval)
        return res
```

---

## ðŸ”¹ Example Walkthrough

Input: `intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]]`, `newInterval = [4,8]`
Process:

* `[1,2]` â†’ after-case â†’ `res=[[1,2]]`
* `[3,5]` overlap â†’ `new=[3,8]`
* `[6,7]` overlap â†’ `new=[3,8]`
* `[8,10]` overlap/touching â†’ `new=[3,10]`
* End â†’ append `new` â†’ **`[[1,2],[3,10],[12,16]]`**

---

## ðŸ”¹ 80/20 (8ty)

* **80% win:** Memorize the three-case logic.
* **20% finesse:** Early return on before-case; avoid extra scans and merges.

---

## ðŸ”¹ Common Misconceptions (cm)

* "We must resort after insertion" â†’ No; the initial order is preserved by construction.
* "Merge later is safer" â†’ Inline merge is simpler and equally correct.
* "Touching endpoints always overlap" â†’ Depends on problem definition; here we only treat `start <= end` overlaps; adjust for open/closed intervals as needed.

---

## ðŸ”¹ Further Notes / Variations

* If intervals could be unsorted or overlapping initially, first **merge** them (classic merge-intervals) then apply this insertion.
* With different overlap semantics (open/closed), rewrite comparisons accordingly.
